/*
 Navicat Premium Data Transfer

 Source Server         : myblog
 Source Server Type    : MySQL
 Source Server Version : 50721
 Source Host           : localhost
 Source Database       : myblog

 Target Server Type    : MySQL
 Target Server Version : 50721
 File Encoding         : utf-8

 Date: 11/21/2019 15:54:37 PM
*/

SET NAMES utf8;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
--  Table structure for `album`
-- ----------------------------
DROP TABLE IF EXISTS `album`;
CREATE TABLE `album` (
  `id` int(8) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL COMMENT '昵称',
  `desc` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '密码',
  `tags` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '邮箱',
  `createtime` datetime NOT NULL,
  `views` int(8) DEFAULT '0',
  `likes` int(8) DEFAULT '0',
  `channel` int(10) NOT NULL,
  `cover` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `author` int(8) NOT NULL,
  `rec` int(2) DEFAULT '0',
  `imgcount` int(2) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `album`
-- ----------------------------
BEGIN;
INSERT INTO `album` VALUES ('31', 'Gavin Thomas', null, '[\"假笑男孩\",\"表情包\"]', '2019-04-14 00:33:11', '36', '3', '13', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555183231634&di=adae467a9c3996b9dad86b1d1acb103e&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201802%2F11%2F20180211184725_MvyVE.jpeg', '17', '1', '3'), ('32', 'HoWanChung', 'Havana ​​​​ -- from weibo', '[\"写真\"]', '2019-05-27 22:33:21', '80', '1', '11', 'http://www.lsshuai.com/server/static/302931504@qq.com/album/21087446e08f5.jpeg', '17', '1', '3'), ('33', 'Cameron Monaghan', 'The Joker from Gotham', '[\"小丑\",\"卡梅隆·莫纳汉\"]', '2019-05-28 17:24:28', '137', '6', '11', 'http://www.lsshuai.com/server/static/302931504@qq.com/album/21087446e08f5.jpeg', '17', '1', '3'), ('34', 'Pakho 周柏豪', null, '[\"周柏豪\"]', '2019-05-28 17:26:06', '28', '0', '11', 'http://www.lsshuai.com/server/static/302931504@qq.com/album/9718a5f88731f.jpeg', '17', '1', '4'), ('36', 'body', '公平吗？', '[\"落尔洛\"]', '2019-08-01 17:32:48', '4', '0', '11', 'http://www.lsshuai.com/server/static/302931504@qq.com/album/9718a5f88731f.jpeg', '18', '0', '2');
COMMIT;

-- ----------------------------
--  Table structure for `articles`
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(100) COLLATE utf8_unicode_ci NOT NULL COMMENT '标题',
  `author` int(8) NOT NULL COMMENT '作者',
  `pubtime` timestamp NULL DEFAULT NULL COMMENT '发布时间',
  `views` int(10) unsigned DEFAULT '0' COMMENT '阅读数',
  `likes` int(10) unsigned DEFAULT '0' COMMENT '点赞数',
  `content` text COLLATE utf8_unicode_ci COMMENT '内容',
  `imgcover` varchar(500) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '封面',
  `channel` int(8) NOT NULL COMMENT '频道',
  `desc` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '简介',
  `tags` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '标签',
  `createtime` timestamp NULL DEFAULT NULL,
  `show` tinyint(2) NOT NULL,
  `comments` int(10) DEFAULT '0',
  `rec` int(2) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `articles`
-- ----------------------------
BEGIN;
INSERT INTO `articles` VALUES ('34', '震惊', '18', '2019-04-15 11:06:53', '7', '0', '<p>/server/static/986584713@qq.com/article/db13dce5faae2.jpg</p><p>很狗</p>', '/server/static/986584713@qq.com/article/db13dce5faae2.jpg', '11', '站长手机丢了，智商突然下线', null, '2019-04-15 11:04:26', '0', '0', '0'), ('35', '详解JavaScript面向对象编程(一)', '17', '2019-04-15 23:14:46', '53', '0', '<h1 style=\"text-align:start;text-indent:2em;\">前言</h1><p style=\"text-align:start;text-indent:2em;\">面向对象语言都有类的概念，但是ECMAScript没有，因此它的对象同其他OO语言的对象也有所不同；<br/>对象即一组无序属性的集合，每个属性都有一个名字(字符串)，每个名字都映射一个值，这个值可以是普通值、对象和函数；我们可以用对象存储哈希表。</p><h2 style=\"text-align:start;text-indent:2em;\">ECMAScript中有两种属性：</h2><h3 style=\"text-align:start;text-indent:2em;\">1. 数据属性</h3><p style=\"text-align:start;text-indent:2em;\">每一个数据属性都包含有四个特性：</p><ul><li>[[Configurable]]: 布尔值，表示能否用DELETE删除，能否修改属性为访问器属性，默认为true</li><li>[[Enumerable]]: 布尔值，表示能否通过for-in循环返回属性，默认为true</li><li>[[Writable]]: 布尔值，表示能否修改属性，默认为true</li><li>[[Vlaue]]: 数据的值，默认为undefined</li></ul><p style=\"text-align:start;text-indent:2em;\">必须通过Object.defineProperty()方法来修改属性的默认特性，如：</p><pre><code>var person = {};<br/>Object.defineProperty(person, <span style=\"font-size:12px\"><span style=\"color:#c18401\">name</span></span>, {<br/>  value: <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>,<br/>  writable: <span style=\"font-size:12px\"><span style=\"color:#0184bb\">false</span></span> <br/>});<br/><br/>person.<span style=\"font-size:12px\"><span style=\"color:#c18401\">name</span></span>; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;chenlei&quot;</span></em></span><br/>person.<span style=\"font-size:12px\"><span style=\"color:#c18401\">name</span></span> = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenjunbin&quot;</span></span> <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 忽略或报错，因为writable设置为false   </span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">注意：可以通过Object.defineProperty()对同一属性多次修改，但若把[[Configurable]]设置为false后，就不能修改除了[[Writable]] 之外的特性了；使用Object.defineProperty()定义属性若不显示的指明三个布尔值特性的值将默认为false。</p><h3 style=\"text-align:start;text-indent:2em;\">2. 访问器属性</h3><ul><li>[[Configurable]]: 布尔值，表示能否用DELETE删除，能否修改属性为访问器属性，默认为true</li><li>[[Enumerable]]: 布尔值，表示能否通过for-in循环返回属性，默认为true</li><li>[[Get]]: 读取属性时调用的函数，默认值为undefined</li><li>[[Set]]: 设置属性值时调用的函数，默认值为undefined</li></ul><p style=\"text-align:start;text-indent:2em;\">同样，设置访问器属性的特性一样要用Object.defineProperty()方法，如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> person = {<br/>  name: <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>,<br/>  _age: <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>,<br/>  edition: <span style=\"font-size:12px\"><span style=\"color:#986801\">1</span></span><br/>};  <br/><br/>Object.defineProperty(person, age, {<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">get</span></span>: <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>._age;<br/>  },<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">set</span></span>: <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> (newval) </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">if</span></span> (<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>._age &gt; newval) {<br/>      <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.edition++;<br/>    }<br/>  }<br/>});  <br/><br/>person.age = <span style=\"font-size:12px\"><span style=\"color:#986801\">20</span></span>;<br/>person.edition; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 2</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">获取属性的特性可以通过Object.getOwnPropertyDescriptor()方法，接收两个参数，第一个是获取属性特性所在的对象，第二个是属性名，返回一个含有属性特性的对象；</p><h1 style=\"text-align:start;text-indent:2em;\">创建对象的方式</h1><h3 style=\"text-align:start;text-indent:2em;\">1. 工厂方式</h3><p style=\"text-align:start;text-indent:2em;\">工厂方式即用一个函数来封装构建函数的细节，函数返回一个对象，构造对象时调用这个函数就可以了，如下：</p><pre><code>function createPerson(name, age, <span style=\"font-size:12px\"><span style=\"color:#a626a4\">job) </span></span>{<br/>  var o = new Object()<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">;</span></em></span><br/>  o.name = name<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">;</span></em></span><br/>  o.age = age<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">;</span></em></span><br/>  o.<span style=\"font-size:12px\"><span style=\"color:#a626a4\">job </span></span>= <span style=\"font-size:12px\"><span style=\"color:#a626a4\">job;</span></span><br/>  return o<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">;</span></em></span><br/>}<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">;</span></em></span><br/><br/>var person1 = createPerson(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;student&quot;</span></span>)<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">;   </span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">优点：创建多个相似对象只需调用一个函数就可以了；<br/>缺点： 无法判断这个对象的类型；</p><h3 style=\"text-align:start;text-indent:2em;\">2. 构造函数模式</h3><p style=\"text-align:start;text-indent:2em;\">直接看例子：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> (name, age, job) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name = name;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.age = age;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.job = job;  <br/><br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.sayHi = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;hi!&quot;</span></span> + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>  }<br/>}  <br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> person1 = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> Person(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;student&quot;</span></span>);  <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">我们看到这个与上面工厂函数相比，构造函数内部没有显示的声明对象，也没有返回值，而且调用时必须使用new操作符；<br/>调用一个构造函数来创建对象经历以下四步：<br/>-创建对象<br/>-将构造函数作用域赋给新对象<br/>-执行构造函数里的代码<br/>-返回新对象</p><p style=\"text-align:start;text-indent:2em;\">构造函数相比与工厂模式是可以判断对象的类型，如上面调用Person构造函数创建的类型我们人可以这样判断：</p><pre><code>console.log(person1<span style=\"font-size:12px\"><span style=\"color:#c18401\"> instance </span></span>of Person); // true<br/>console.log(person1<span style=\"font-size:12px\"><span style=\"color:#c18401\"> instance </span></span>of Object); // true  <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">缺点呢就是上面的sayHi方法没有被复用，每创建一个新对象就新建了一个sayHi()函数，然而sayHi()函数实现的功能是完全一样的，因此我们可以这样做：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> (name, age, job) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name = name;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.age = age;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.job = job;  <br/><br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.sayHi = sayHi;<br/>} <br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">sayHi</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;hi!&quot;</span></span> + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>} <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">因为函数名是一个指针，我们把sayHi赋值给this.sayHi实际上就是把sayHi函数的地址给了this.sayHi，每新建一个对象只是对改函数新增了一个引用，每个对象调用的sayHi()都是指向的同一个函数，调用sayHi()时里面的this会指向调用它的对象；<br/>这样虽然解决了创建多个相同函数的问题，但是又新增了问题，就是当对象的方法很多时，就要在全局作用域新建许多的方法，这样就破坏了自定义的引用类型的封装性。</p><p style=\"text-align:start;text-indent:2em;\">优点：能够判断对象的类型<br/>缺点：重复创建相同函数或者破坏了自定义引用类型的封装性</p><h3 style=\"text-align:start;text-indent:2em;\">3. 原型模式</h3><p style=\"text-align:start;text-indent:2em;\">每个函数都有一个原型对象，因此我们可以在函数的原型对象上建属性和方法，这样调用这个构造函数创建的对象就能共享该函数原型上的实例和方法了，如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> () </span>{};<br/><br/>Person.prototype.name = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>;<br/>Person.prototype.age = <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>;<br/>Person.prototype.job = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;student&quot;</span></span>;<br/><br/>Person.prototype.sayHi = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;hi!&quot;</span></span> + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> person1 = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> Person();   <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">我们用原型模式构造一个对象时不用传入参数，所有对象实例共享原型上属性和方法，这样就避免了我们在全局作用域定义方法来供所有实例对象使用，但是当原型上的属性存在引用类型的值时，就显得不那么方便了，如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> () </span>{};<br/><br/>Person.prototype.name = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>;<br/>Person.prototype.age = <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>;<br/>Person.prototype.job = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;student&quot;</span></span>;<br/>Person.prototype.friends = [<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;chenjunbin&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;linweiming&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;zenpeisen&#x27;</span></span>];<br/><br/>Person.prototype.sayHi = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;hi!&quot;</span></span> + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> person1 = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> Person ();<br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> person2 = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> Person ();<br/><br/>person1.friends.push(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;lanlan&quot;</span></span>);<br/>person2.friends; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;chenjunbin&quot;,&quot;linweiming&quot;,&quot;zenpeisen&quot;,&quot;lanlan&quot;  </span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">可以看到，person1.friends的变化会影响到person2，我们也可以给person2的friends重新赋一个值来屏蔽原型上的值，但这也就失去了我们使用原型模式构造对象的意义，就是实现共享。</p><p style=\"text-align:start;text-indent:2em;\">优点：让所有实例对象共享原型上的属性和方法<br/>缺点：当原型上的属性存在引用类型值时显得不那么方便</p><h3 style=\"text-align:start;text-indent:2em;\">4. 组合使用构造函数和原型模式</h3><p style=\"text-align:start;text-indent:2em;\">这个方法其实就是将构造函数和原型模式两种方式结合起来，把对象实例的属性在构造函数里定义，共享的属性和方法在原型上定义，如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> (name, age, job) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name = name;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.age = age;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.job = job;  <br/><br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.friends = [<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;chenjunbin&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;linweiming&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;zenpeisen&#x27;</span></span>];<br/>} <br/><br/>Person.prototype.sayHi = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;hi!&quot;</span></span> + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>}<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">这样，friends属性除了初始的值外可以往里面添加，而且各个实例互不影响，而且它们也都共享原型上的sayHi方法；<br/>这种方法是目前ECMAScript使用最广泛的自定义类型方法。</p><h3 style=\"text-align:start;text-indent:2em;\">5. 动态原型模式</h3><p style=\"text-align:start;text-indent:2em;\">即在原型模式的基础之上进行了改进，把在原型上定义的属性和方写进构造函数里，并且在必要的时候初始化原型，如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> (name, age, job) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name = name;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.age = age;<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.job = job;  <br/><br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.friends = [<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;chenjunbin&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;linweiming&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;zenpeisen&#x27;</span></span>];<br/><br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">if</span></span> (type <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.sayHi != <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;function&#x27;</span></span>) {<br/>    Person.prototype.sayHi = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>      <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;hi!&quot;</span></span> + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>    }<br/>  }  <br/>} <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">优点：动态决定是否要在原型上定义方法；</p><h3 style=\"text-align:start;text-indent:2em;\">6. 寄生构造函数模式</h3><p style=\"text-align:start;text-indent:2em;\">常用代码如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> (name, age, job) </span>{<br/>  ar o = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#c18401\">Object</span></span>();<br/>  o.name = name;<br/>  o.age = age;<br/>  o.job = job;<br/>  o.sayHi = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;hi!&quot;</span></span> + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>  }<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> o;<br/>}<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">从上面我们看出这个方法跟工厂模式几乎一样，我一开始对这种方法有点迷惑它到底有什么用，我们再来看下一个例子：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">MyArray</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> arr = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#c18401\">Array</span></span>();<br/>  arr.push.apply(arr, <span style=\"font-size:12px\"><span style=\"color:#c18401\">arguments</span></span>);<br/>  arr.toPipedString = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.join(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;|&quot;</span></span>);<br/>  }<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> arr;<br/>} <br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> arr1 = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> MyArray(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;1&quot;</span></span>,<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;2&quot;</span></span>,<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;3&quot;</span></span>);<br/><span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(arr1.toPipedString); <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">//&quot;1|2|3&quot;</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">我们自定义一个构造函数，然后在里面新建一个数组对象，然后给这个数组对象实例添加一个方法并返回这个数组对象实例，这样其实就是我们自己定义了一个有数组多有功能并切还多了一个方法的特殊数组构造函数，因为原生的构造函数我们不能修改，因此我们可以用这种方法来模拟。</p><p style=\"text-align:start;text-indent:2em;\">优点：模拟修改原生构造函数 缺点：不能判断对象类型，即：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(arr1 <span style=\"font-size:12px\"><span style=\"color:#a626a4\">instanceof</span></span> MyArray); <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// false</span></em></span><br/><span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(arr1 <span style=\"font-size:12px\"><span style=\"color:#a626a4\">instanceof</span></span> <span style=\"font-size:12px\"><span style=\"color:#c18401\">Array</span></span>); <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// true  </span></em></span><br/></code></pre><h3 style=\"text-align:start;text-indent:2em;\">7. 稳妥构造函数模式</h3><p style=\"text-align:start;text-indent:2em;\">这种方式不用this,调用它时也不用new：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">Person</span> (name, age, job) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> o = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#c18401\">Object</span></span>();<br/><br/>  <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 定义私有变量</span></em></span><br/><br/>  o.sayName = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(name);<br/>  }<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> o;<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> person1 = Person(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;student&quot;</span></span>);<br/>person1.sayName();  <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;chenlei&quot;  </span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">上面只能使用sayName()方法访问name属性；</p><p style=\"text-align:start;text-indent:2em;\">优点： 提供一种安全性安全，非常适合在一些安全执行环境</p><h3 style=\"text-align:start;text-indent:2em;\">8. ES6新增class</h3><p style=\"text-align:start;text-indent:2em;\">文章开篇提到过在ECMAScript中是不存在“类”的概念的，ES6中提供<em>class</em>关键字来定义一个类使之更加接近其他OO语言，使用<em>class</em>来声明一个对象的基本写法如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">Person</span> </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">constructor</span></span> (name, age, job) {<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name = name;<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.age = age;<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.job = job;<br/>  }<br/><br/>  sayHi () {<br/>    console.log(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>  } <br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> person1 = new Person(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;student&quot;</span></span>);  <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">由上我们通过<em>class</em>来重构之前的例子，我们要创建一个实例对象同样要使用new操作符，这种方法不仅是语法上更接近其他OO语言，还把定义一个对象的方法封装在一起了；<br/>上面的<em>constructor</em>就是我们用new操作符起作用的地方，class类里面的所有方法都是定义在它的原型对象上的，也就是说上面的写法等同于下面的写法：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">Person</span> </span>{};<br/><br/>Person.prototype = {<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">constructor</span></span> () {}，<br/>  sayHi () {}，<br/>};<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">同样class声明同样可以采用表达式形式定义，如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">const</span></span> People = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">Person</span> </span>{<br/>  getName () {<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> Person.name;<br/>  } <br/>}<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">需要注意的是，这个上面的类名是People而不是Person，Person只在内部使用指代当前的类；</p><p style=\"text-align:start;text-indent:2em;\">与ES5中定义对象的不同指出：</p><ul><li>class内部的所有方法都是不可枚举的，而ES5中的定义在原型上的方法是可枚举的</li><li>不存在变量提升，也就是说在调用一个类之前必须先定义它，否则会报错</li><li>不使用new操作符调用会报错，而ES中的构造函数不会</li><li>类的内部默认使用的是严格模式</li></ul><p style=\"text-align:start;text-indent:2em;\">class类中还存在静态属性和静态方法是不能被继承的，关于class类的继承方法将在下一篇文章中和其他几种继承方法一起讲。</p>', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555351321041&di=970c5055fed6b85f7537b45d2676562e&imgtype=0&src=http%3A%2F%2Fnews.mydrivers.com%2Fimg%2F20170414%2F4a584bd038434126bcbdd7942f919d24.jpg', '12', '这篇文章作为《详解JavaScript面向对象编程》的上半部分讲解了在JavaScript中如何实现面向对象的编程，在ECMAScript中对象的定义以及对象的两种属性类型，还梳理了构建对象的几种方法，包括了es6中新引入的类', '[\"基础知识\",\"面向对象\",\"class类\"]', '2019-04-15 23:14:46', '1', '0', '1'), ('36', '详解JavaScript面向对象编程(二)', '17', '2019-04-15 23:17:58', '27', '1', '<p style=\"text-align:start;text-indent:2em;\">上一篇文章主要讲了js中对象的构建方法，<a href=\"http://www.lsshuai.com/article/11\" target=\"\">[点击跳转]</a>，本文将着重讲对象的继承；</p><h1 style=\"text-align:start;text-indent:2em;\">原型链</h1><p style=\"text-align:start;text-indent:2em;\">原型链是ECMAScript中的重要概念，理解原型链我们先理解这三者之间的关系，即构造函数、构造函数的原型对象和调用构造函数生成的对象实例之间的关系，看下面的图片：<br/></p><div class=\"media-wrap image-wrap align-start\" style=\"text-align:start\"><img src=\"http://lsshuai.com/blog/1010198-20170222151629288-2040292378.png\" width=\"1000px\" style=\"width:1000px\"/></div><p style=\"text-align:start;text-indent:2em;\"><br/>如上图，我们可以看出函数有一个prototype 属性指向它的原型对象，原型对象有一个constructor属性指向函数，调用函数生成的对象又一个<em><strong>__proto</strong></em> <em>__</em>属性指向原型对象;</p><p style=\"text-align:start;text-indent:2em;\">这里我们先建立两个构造函数并在它们的原型对象上建立两个函数：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">A</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.a = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;a&#x27;</span></span>;<br/>}<br/><br/>A.prototype.sayA = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.a);<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">B</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.b = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;b&#x27;</span></span>;<br/>}<br/><br/>B.prototype.sayB = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.b);<br/>}<br/></code></pre><h2 style=\"text-align:start;text-indent:2em;\"><em><strong>constructor</strong></em></h2><p style=\"text-align:start;text-indent:2em;\">我们在打印台分别打印出它们的constructor属性</p><p style=\"text-align:start;text-indent:2em;\"></p><div class=\"media-wrap image-wrap align-start\" style=\"text-align:start\"><img src=\"http://lsshuai.com/blog/154F3429-CBA7-45AE-9964-CE838D93C8BE.png\" width=\"1000px\" style=\"width:1000px\"/></div><p style=\"text-align:start;text-indent:2em;\"><br/>此时我们增加这一行代码：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">A</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.a = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;a&#x27;</span></span>;<br/>}<br/><br/>A.prototype.sayA = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.a);<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">B</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.b = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;b&#x27;</span></span>;<br/>}<br/><br/>B.prototype.sayB = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/> <span style=\"font-size:12px\"><span style=\"color:#c18401\">console</span></span>.log(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.b);<br/>}  <br/><br/>B.prototype = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> A();  <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">//新增代码   </span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">然后我们再来分别打印它们的<em>constructor</em>：</p><p style=\"text-align:start;text-indent:2em;\"></p><div class=\"media-wrap image-wrap align-start\" style=\"text-align:start\"><img src=\"http://lsshuai.com/blog/B85E3E2E-D49B-41FA-AFCA-87041720AD6A.png\" width=\"1000px\" style=\"width:1000px\"/></div><p style=\"text-align:start;text-indent:2em;\"><br/>我们看到B的原型的constructor指向了A,这是因为B的原型指向了A的原型，而A的原型的constructor是指向A的；</p><h2 style=\"text-align:start;text-indent:2em;\"><em><strong>__proto</strong></em> <em>__</em></h2><p style=\"text-align:start;text-indent:2em;\"><em><strong>__</strong>proto __</em>是对象的一个隐式属性，指向当前的原型对象；<br/>我们生成一个B的实例：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> ins = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#986801\">B</span></span>();   <br/><br/>ins.__proto__ === B.prototype; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// true</span></em></span><br/>B.prototype.__proto__ == A.prototype; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// true</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">然后看我们打印b的这几个属性：<br/></p><div class=\"media-wrap image-wrap align-start\" style=\"text-align:start\"><img src=\"http://lsshuai.com/blog/5C5E4673-B246-4E94-8C24-5A9DE393E144.png\" width=\"1000px\" style=\"width:1000px\"/></div><p style=\"text-align:start;text-indent:2em;\"><br/>我们先打印的ins.b，因为b在ins实例中，所以打印出“b”，我们在打印ins.a，a不在ins实例中，但是a在B.prototype中，所以ins能够访问到a，sayA()方法是A.prototype上的方法，不在ins中也不在B.prototype中，因为B.prototype的 <em><strong>__</strong>proto __</em>指向A.prototype,所以ins能够访问到，但是最后的sayB()却报错了，说sayB()不是一个函数，我们之前明明在B.prototype定义了这个方法，为什么访问不到了呢？原因是<em>B.prototype = new A();</em>这段代码为B重新指定了原型，这个原型目前只有一个a属性，所以ins访问不到，我们只能重新在B.prototype上定义sayB()方法；</p><p style=\"text-align:start;text-indent:2em;\">由上我们可以总结原型链继承的原理，让一个对象继承另一个对象的属性和方法，即让一个对象的原型作为另一个对象的实例，此时这个对象的原型就继承了另一个原型的属性和方法，当生成第一个对象的实例时，这个实例对象就继承了其原型和另一个对象的属性和方法，举个栗子，我们要访问上面ins对象的sayA()方法先在ins实例中找，没找到便向B.prototype上找，也没找到，便向A.prototype上找，好了，找到了，就返回该方法，这种查找就是原型链查找，ins继承B.prototype，B.prototype继承A.prototype，这就叫原型链继承；<br/>注意，我们可以重写属性和方法，比如a是在B.prototype上的，我们可以直接为ins指定一个属性a</p><pre><code>ins.a = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;c&#x27;</span></span>;<br/><br/>ins.a; <span style=\"font-size:12px\"><span style=\"color:#50a14f\">//</span></span> <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;c&quot;</span></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">因为原型链查找方式是依次往上的，如果a在ins实例中找到了就不再往上找了，这叫做<strong>属性屏蔽</strong>，若要访问原始的a，我们可以使用<em>B.prototype.a</em>来访问，同样，也可以重写sayA()方法。</p><p style=\"text-align:start;text-indent:2em;\">如果我们采用字面量的方式来为原型添加新方法，如下：</p><pre><code>B.prototype = {<br/>  dd () {<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;dd&quot;</span></span>;<br/>  },<br/>  ee () {<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;ee&quot;</span></span>;<br/>  }<br/>}<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">这是B.prototype被重写将不指向A的原型了，指向所有对象的默认原型<em>Object.prototype</em>，默认原型是<em>Object.prototype</em>也是为什么所有自定义类型都会继承toString()和valueOf()等方法的原因。</p><p style=\"text-align:start;text-indent:2em;\">原型链跟上一篇讲的原型构造对象存在一样的缺点，即当对象继承的属性包括引用类型值时，此时所有的实例都会继承这个引用类型值的属性，因此其中一个属性修改它那它的修改将会反射到所有的实例上，其次就是子类型实例不能向超类型构造函数传递参数。</p><h1 style=\"text-align:start;text-indent:2em;\">借用构造函数</h1><p style=\"text-align:start;text-indent:2em;\">这种方法即在子类型构造函数中调用超类型构造函数，通过call()或apply()来传递实例对象，如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">A</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.friends: [<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;liu&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;chen&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;lin&#x27;</span></span>]<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">B</span> () </span>{<br/>  A.call(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>);<br/>} <br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> b1 = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> B();<br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> b2 = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> B(); <br/><br/>b1.friends.push(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;zhang&#x27;</span></span>);<br/>b2.friends; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;liu&quot;, &quot;chen&quot;, &quot;lin&quot;</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">从上面代码我们可以看出b1的操作并不会影响b2的friends,这是因为在B中传递的是不同的实例对象，而且我们也可以向超类型构造函数传递参数，如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">A</span> (name) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name = name;<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">B</span> (age, name) </span>{<br/>  A.call(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>, name);<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.age = age;<br/>} <br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> b = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> B(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;leizi&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>); <br/><br/>b.name; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;leizi&quot;</span></em></span><br/>b.age; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 22  </span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">借用构造函数其实就是调用超类型构造函数在子类型函数里生成超类型中有的属性，它解决了原型链继承的这两个问题，但是我们定义方法只能在函数内部定义，而每一个实例实现相同功能的函数其实又是不同的函数，这就失去了函数复用的意义。</p><h1 style=\"text-align:start;text-indent:2em;\">原型链构造函数组合继承(组合继承)</h1><p style=\"text-align:start;text-indent:2em;\">融合两种方法，如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">A</span> (name) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name = name;<br/>}<br/><br/>A.prototype.sayName = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>  alert(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.name);<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">B</span> (age, name) </span>{<br/>  A.call(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>, name);<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.age = age;<br/>} <br/><br/>B.prototype = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> A();<br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> b = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> B(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;leizi&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>);  <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">此时b实例就可以调用A原型上的sayName()方法了；这个方法看似很好，融合了原型链和构造函数继承的优点，但是，这个方法它调用了两次A构造函数，一次是生成A的实例，一次是在B内部调用A；</p><h1 style=\"text-align:start;text-indent:2em;\">原型式继承</h1><p style=\"text-align:start;text-indent:2em;\">我们来看下面的代码：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> o = {<br/>  name = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>,<br/>  age = <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>;<br/>};<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">F</span> () </span>{};<br/>F.prototype = o;<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> f = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> F();<br/><br/>f.name; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">//&quot;chenlei&quot;</span></em></span><br/>f.age; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 22  </span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">这种方法即直接把一个对象赋值给构造函数的原型对象，使其实例对象能够访问到o中的属性和方法从而实现继承，原型式继承就是将这种方法封装起来，如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">object</span> (o) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">F</span>() </span>{};<br/>  F.prototype = o;<br/><br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> F();<br/>}<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">ECMAScript新增<em>Object.create()</em>方法来实现原型式继承，它接收两个参数，第一个为需要继承的基对象，第二个是要额外或者修改的参数，第二个参数格式与<em>Object.defineProperties()</em>方法的第二个参数格式一样，即：</p><pre><code>var <span style=\"font-size:12px\"><span style=\"color:#986801\">o</span></span> = {<br/>  <span style=\"font-size:12px\"><span style=\"color:#986801\">name</span></span> = <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;chenlei&quot;</span></span>,<br/>  <span style=\"font-size:12px\"><span style=\"color:#986801\">age</span></span> = <span style=\"font-size:12px\"><span style=\"color:#986801\">22</span></span>;<br/>};<br/><br/>var <span style=\"font-size:12px\"><span style=\"color:#986801\">f</span></span> = Object.create(o, {<br/>  name: {<br/>    value: <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&quot;leizi&quot;</span></span><br/>  }<br/>});  <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">种种方式的继承跟原型链继承一样存在引用类型值时修改将会反射到所有继承的实例中。</p><h1 style=\"text-align:start;text-indent:2em;\">寄生式继承</h1><p style=\"text-align:start;text-indent:2em;\">这种方式的继承在为一个内置引用类型添加自定义方法时又用，如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">myArray</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> arr = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#c18401\">Array</span></span>();<br/>  arr.push.apply(arr, <span style=\"font-size:12px\"><span style=\"color:#c18401\">arguments</span></span>);<br/>  arr.toPipedString = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> arr.join(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;|&#x27;</span></span>);<br/>  };<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> arr;<br/>};<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> myarr = myArray(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;red&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;green&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;black&#x27;</span></span>);<br/><br/>myarr.toPipedString(); <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;red|green|black&quot;</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">上面通过寄生继承的方法返回一个有toPipedString()方法的特殊数组，它继承有数组的所有方法，还有自定义的方法。</p><p style=\"text-align:start;text-indent:2em;\">同样，由于函数在内部定义而得不到复用。</p><h1 style=\"text-align:start;text-indent:2em;\">组合寄生式继承</h1><p style=\"text-align:start;text-indent:2em;\">即通过借用构造函数继承来继承超类型饿的属性，通过原型链的混成来继承超类型方法，</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">inheritPrototype</span>(subType, superType) </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> pro = <span style=\"font-size:12px\"><span style=\"color:#c18401\">Object</span></span>.create(superType.prototype);<br/>  pro.constructor = subType; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">//增强对象</span></em></span><br/>  subType.prototype = pro;<br/>}<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">这种方法很好的改善了组合继承的调用两次超类型构造函数的缺点，第一次调用在子类型的原型上生成了超类型的属性，第二次调用又在子类型内部生成了超类型的属性，从而或屏蔽子类型原型上的属性，寄生组合式继承，子类型内部继承超类型的属性，子类型原型上就继承超类型的方法，从而改善组合继承。</p><h1 style=\"text-align:start;text-indent:2em;\">ES6 class类的继承</h1><p style=\"text-align:start;text-indent:2em;\">上一篇我们讲了ES6新引进的class来创建对象，这一篇我们在这里来讲class的继承；</p><h2 style=\"text-align:start;text-indent:2em;\"><em><strong>extends</strong></em></h2><p style=\"text-align:start;text-indent:2em;\">我们先来看一下java实现类的继承的方法：</p><pre><code> public <span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">o</span> <span style=\"color:#a626a4\">extends</span> <span style=\"color:#c18401\">Object</span> </span>{} <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">java是通过<em>extends</em>来实现类的继承，同样，ES6为了更贴近其他OO语言，也是采用的<em>extends</em>关键字， 如：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">A</span> </span>{};<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">B</span> <span style=\"color:#a626a4\">extends</span> <span style=\"color:#c18401\">A</span> </span>{};  <br/></code></pre><p style=\"text-align:start;text-indent:2em;\">上面子类B继承了A；</p><p style=\"text-align:start;text-indent:2em;\">在ES5中我们知道不能给内置对象添加自定义方法，所以我们采用寄生式构造函数的方式来创建一个对象，它拥有自定义的方法和内置对象的所有方法，但在ES6的Class中我们可以直接让子类<em>extends</em>内置对象，如我们之前的例子：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> <span style=\"color:#4078f2\">MyArray</span> () </span>{<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> arr = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#c18401\">Array</span></span>();<br/>  arr.push.apply(arr, <span style=\"font-size:12px\"><span style=\"color:#c18401\">arguments</span></span>);<br/>  arr.toPipedString = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">function</span> () </span>{<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.join(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;|&#x27;</span></span>);<br/>  };<br/>  <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> arr;<br/>};<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> myarr = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> MyArray(<span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;red&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;green&#x27;</span></span>, <span style=\"font-size:12px\"><span style=\"color:#50a14f\">&#x27;black&#x27;</span></span>);<br/><br/>myarr.toPipedString(); <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;red|green|black&quot;</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">这个例子是构造一个有特殊方法的数组，因为我们不能直接在Array上新增方法，我们用Class来改写：</p><pre><code> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">MyArray</span> <span style=\"color:#a626a4\">extends</span> <span style=\"color:#c18401\">Array</span> </span>{<br/>   constructor () {<br/>     <span style=\"font-size:12px\"><span style=\"color:#a626a4\">super</span></span>();<br/>     <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.arr = [...arguments];<br/>   }<br/><br/>   toPipedString () {<br/>     <span style=\"font-size:12px\"><span style=\"color:#a626a4\">return</span></span> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.arr.join(&#x27;|&#x27;);<br/>   }<br/> }<br/><br/> <span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> myarr = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#986801\">MyArray</span></span>(<span style=\"font-size:12px\"><span style=\"color:#4078f2\">&#x27;re</span></span>d&#x27;, <span style=\"font-size:12px\"><span style=\"color:#4078f2\">&#x27;gree</span></span>n&#x27;, <span style=\"font-size:12px\"><span style=\"color:#4078f2\">&#x27;blac</span></span>k&#x27;);<br/><br/>myarr.toPipedString(); <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// &quot;red|green|black&quot;</span></em></span><br/></code></pre><h2 style=\"text-align:start;text-indent:2em;\"><em><strong>super</strong></em></h2><p style=\"text-align:start;text-indent:2em;\">在class类中，super是指超类型，它有两种使用方式，如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">A</span> </span>{<br/>  constructor (x, y) {<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.x = x;<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.y = y;<br/>  }<br/><br/>  add () {<br/>    console.log(<span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.x + <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.y); <br/>  }  <br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">B</span> <span style=\"color:#a626a4\">extends</span> <span style=\"color:#c18401\">A</span> </span>{<br/>  constructor (x, y, z) {<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">super</span></span>(x, y);<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.z = z;<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.p = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">super</span></span>.add();<br/>  }<br/>}<br/><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">var</span></span> b = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">new</span></span> <span style=\"font-size:12px\"><span style=\"color:#986801\">B</span></span>(<span style=\"font-size:12px\"><span style=\"color:#986801\">10</span></span>, <span style=\"font-size:12px\"><span style=\"color:#986801\">12</span></span>);<br/>b.x; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 10</span></em></span><br/>b.y; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 12</span></em></span><br/>b.p; <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">// 22</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">如上，当super作为构造函数时指向的是类A的constructor，当super作为对象时，在普通方法中使用则是指向父类的原型，当在静态方法中使用时指向父类，即上面的<em>super.add()</em>实际上等于<em>A.prototype.add()</em>；</p><p style=\"text-align:start;text-indent:2em;\">ES6规定必须在子类的constructor中用一次super,且内部的this使用必须在super之后，比如这样将报错：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">class</span> <span style=\"color:#c18401\">B</span> <span style=\"color:#a626a4\">extends</span> <span style=\"color:#c18401\">A</span> </span>{<br/>  constructor (x, y, z) {<br/>   <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.z = z;  <span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">//TypeError</span></em></span><br/>   <span style=\"font-size:12px\"><span style=\"color:#a626a4\">super</span></span>(x, y);<br/>    <span style=\"font-size:12px\"><span style=\"color:#a626a4\">this</span></span>.p = <span style=\"font-size:12px\"><span style=\"color:#a626a4\">super</span></span>.add();<br/>  }<br/>}<br/></code></pre><p style=\"text-align:start;text-indent:2em;\">这是因为Class是先创建父类实例对象this，然后子类的构造函数再修改this，子类自身是没有this对象的，所以先于super()使用this会报错；ES5的继承机制是先创建子类型的this对象，再将父类属性和方法添加到子类型的this上；</p><h2 style=\"text-align:start;text-indent:2em;\"><em><strong>__proto</strong></em> <em>__</em></h2><p style=\"text-align:start;text-indent:2em;\">ES5中对象实例的 <em><strong>__</strong>proto__</em>指向调用的构造函数的原型对象，在Class中，它有 <em><strong>__</strong>proto__</em>和<em>prototype</em>两条继承线，子类的 <em><strong>__</strong>proto__</em>指向父类，子类<em>prototype</em>上的 <em><strong>__</strong>proto__</em>指向父类的<em>prototype</em>，即：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#a626a4\">B.__proto__ </span></span>=== A<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">; //true</span></em></span><br/><span style=\"font-size:12px\"><span style=\"color:#a626a4\">B.prototype.__proto__ </span></span>=== A.prototype<span style=\"font-size:12px\"><em><span style=\"color:#a0a1a7\">; // true</span></em></span><br/></code></pre><p style=\"text-align:start;text-indent:2em;\">判断一个类是否是另一个类的子类可以用<em>Object.getPrototypeOf()</em>方法，如下：</p><pre><code><span style=\"font-size:12px\"><span style=\"color:#986801\">Object</span></span>.getPrototypeOf(<span style=\"font-size:12px\"><span style=\"color:#986801\">B</span></span>) === <span style=\"font-size:12px\"><span style=\"color:#986801\">A</span></span>; // true  <br/></code></pre><p style=\"text-align:start;text-indent:2em;\"><em>(完)</em></p>', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555351321041&di=d06882e42d3a1cf59d4b9e80925984bb&imgtype=0&src=http%3A%2F%2Fp0.qhimg.com%2Ft01a31625fbcc9fd6df.png', '12', '本文列出了对象继承的几种方法，包括原型链的实现原理，ES6的Class的类继承方法', '[\"原型链\",\"基础知识\",\"面向对象\"]', '2019-04-15 23:17:58', '1', '0', '1'), ('38', 'JAVA基础学习之路（七）对象数组的定义及使用', '18', '2019-04-16 23:50:07', '15', '0', '<h1 style=\"text-align:left;text-indent:2em;\"><strong>两种定义方式：</strong></h1><h2 style=\"text-align:left;text-indent:2em;\"><strong>1.动态初始化：</strong></h2><ul><li>定义并开辟数组：类名称 对象数组名[] = new 类名称[长度]</li><li>分布按成：类名称 对象数组名[] = null； 对象数组名 = new 类名称[长度]；</li></ul><p style=\"text-align:left;text-indent:2em;\"> </p><h2 style=\"text-align:left;text-indent:2em;\"><strong>2.静态初始化</strong></h2><p style=\"text-align:left;text-indent:2em;\">　类名称 对象数组名[] = new 类名称[] {对象，对象......};</p><p></p><p style=\"text-align:left;text-indent:2em;\"> </p><p>class Book {</p><p>    private String name;</p><p>    private double price;</p><p>    public Book(String n ,int p) {</p><p>        name = n;</p><p>        price = p;</p><p>    }</p><p>    public void setName(String n) {</p><p>        name = n;</p><p>    }</p><p>    public void setPrice(double p) {</p><p>        price = p;</p><p>    }</p><p>    public String getInfo() {</p><p>        return &quot;书名&quot;+name+&quot;\\n&quot;+</p><p>                &quot;单价&quot;+price;</p><p>    } </p><p>}</p><p> </p><p>public class test2 {</p><p>    public static void main(String args[]) {</p><p>        Book arr[] = new Book[3];//开辟数组 空间</p><p>        arr[0] = new Book(&quot;java&quot;,10);//对象需要分别实例化</p><p>        arr[1] = new Book(&quot;js&quot;,20);</p><p>        arr[2] = new Book(&quot;py&quot;,30);</p><p>        for(int i=0; i&lt;arr.length; i++) {</p><p>            System.out.println(arr[i]);</p><p>            System.out.println(arr[i].getInfo());</p><p>        }</p><p>    }    </p><p>}</p>', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556206961781&di=1f21261ee2d5e3609d89258ba175b03e&imgtype=0&src=http%3A%2F%2Fwww.rimiedu.com%2Fuploads%2F171101%2F1-1G10116444K58.png', '12', '独一无二的武林秘籍', null, '2019-04-16 23:48:20', '1', '0', '0'), ('39', '红黑树实现', '20', '2019-04-17 10:57:06', '16', '1', '<p># 红黑树</p><p>* LINDA</p><p>* 2018/9/25</p><p></p><p>#### 前言</p><p>如果你还是对写红黑树毫无头绪，可以看一下我的思路，从普通二叉搜索树的插入操作是如何一步步“进化”为真正的红黑树的插入操作的。</p><p></p><p>#### 红黑树的四个规则：</p><p></p><p>* (1) 每个结点要么是红的，要么是黑的；</p><p>* (2) 根结点必须为黑的；</p><p>* (3) 若结点为红，它的子节点为黑；</p><p>* (4) 从根结点到 nil 结点之间的黑结点个数相同。</p><p></p><p>由于规则 (4) ，新插入的结点必须为红。</p><p></p><p>结点的数据结构：</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>class rbtree {</p><p>public:</p><p>    enum {RED, BLACK};</p><p>    struct node {</p><p>        int val;     // 插入值</p><p>        int color;   // 颜色</p><p>        node* left;  // 左子结点</p><p>        node* right; // 右子结点</p><p>        node(int v, int c = RED):val(v), color(c),</p><p>        left(nullptr), right(nullptr) { }</p><p>    };</p><p>};</p><p>&#x60;&#x60;&#x60;</p><p></p><p></p><p></p><p>#### 插入操作</p><p></p><p>我们从**普通的二叉搜索的插入操作**一步步进化成**真正的红黑树插入操作**：</p><p></p><p>(1) 我们先来看看普通的二叉搜索树是如何插入元素的：</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>class rbtree {</p><p>public:</p><p>	void insert(int val) {</p><p>    	root = insert(root, val);</p><p>    }</p><p>private:</p><p>    node* root;</p><p>    node* insert(node* root, int val) {</p><p>        if(root == nullptr)</p><p>            return new node(val);</p><p>        if(root-&gt;val &lt; val)</p><p>            root-&gt;right = insert(root-&gt;right, val);</p><p>        if(root-&gt;val &gt; val)</p><p>            root-&gt;left  = insert(root-&gt;left, val);</p><p>        return root;</p><p>    }</p><p>};</p><p>&#x60;&#x60;&#x60;</p><p></p><p>(2) 由规则 (2) ，我们必须把 root 结点改为黑色:</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>class rbtree {</p><p>public:</p><p>    void insert(int val) {</p><p>        root = insert(root, val);</p><p>        root-&gt;color = BLACK; // 规则(2)</p><p>    }</p><p>//...</p><p>};</p><p>&#x60;&#x60;&#x60;</p><p></p><p>(3) 插入结点时，如果它的**父节点为黑**，就**直接插入**，如果**父节点为红**，就需要**做旋转调整平衡**。</p><p></p><p>旋转分两种，一种是单旋，一种是双旋，和AVL树是一样的，只是要互换旋转结点的颜色。</p><p></p><p>单旋（右旋）如下：</p><p>![单旋](https://img-blog.csdn.net/20180925213252132?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p>P、G结点为需要旋转的结点，旋转后它们的颜色交换。这是为了保证规则 (3)、(4) 成立。</p><p></p><p>什么时候会发生单旋呢？</p><p></p><p>对于右旋，插入结点X**小于所在根结点G**的**左子结点P**的值，而且**左子结点P**和**它的左子结点X**的颜色都为**红色**。</p><p></p><p>对于左旋，插入结点**大于所在根结点**的**右子结点**的值，而且**右子结点**和**它的右子结点**的颜色都为**红色**。</p><p></p><p></p><p></p><p>为什么不直接判断左子节点P为红色就好了（因为新插入结点X一定为红色）？</p><p></p><p>这是考虑到其他情况——当 X 不是新插入结点的时候。下面会说到。</p><p></p><p></p><p></p><p>双旋 (先左再右) 如下：</p><p></p><p>![双旋](https://img-blog.csdn.net/20180925213222320?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p></p><p></p><p>什么时候发生双旋呢？</p><p></p><p>对于**先左再右**，插入结点 X 的值**大于所在根结点G**的**左子结点P**，且**左子结点P**和**它的右子结点X**的颜色均为**红色**。</p><p></p><p>对于**先右再左**，插入结点 X 的值**小于所在根结点**的**右子结点**，且**右子结点**和**它的左子结点**的颜色均为**红色**。</p><p></p><p>同样也考虑到其他情况 —— 当结点 X 不是新插入结点。下面会讲到。</p><p></p><p></p><p></p><p>接着，我就要添加这部分的代码了：</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>class rbtree {</p><p>// ...</p><p>private:</p><p>    node* root;</p><p>    node* insert(node* root, int val) {</p><p>        if(root == nullptr)</p><p>            return new node(val);</p><p>        </p><p>        if(root-&gt;val &lt; val) {</p><p>            root-&gt;right = insert(root-&gt;right, val);</p><p>        	if(root-&gt;right-&gt;color == RED</p><p>                 &amp;&amp; root-&gt;right-&gt;val &lt; val</p><p>                 &amp;&amp; root-&gt;right-&gt;right-&gt;color == RED) {</p><p>                // 左旋</p><p>            }</p><p>            if(root-&gt;right-&gt;color == RED</p><p>                 &amp;&amp; root-&gt;right-&gt;val &gt; val</p><p>                 &amp;&amp; root-&gt;right-&gt;left-&gt;color == RED) {</p><p>                // 先右再左</p><p>            }</p><p></p><p>        }</p><p>        if(root-&gt;val &gt; val) {</p><p>            root-&gt;left  = insert(root-&gt;left, val);</p><p>            if(root-&gt;left-&gt;color == RED</p><p>                 &amp;&amp; root-&gt;left-&gt;val &gt; val</p><p>                 &amp;&amp; root-&gt;left-&gt;left-&gt;color == RED) {</p><p>                 // 右旋</p><p>            }</p><p>            if(root-&gt;left-&gt;color == RED</p><p>                 &amp;&amp; root-&gt;left-&gt;val &lt; val</p><p>                 &amp;&amp; root-&gt;left-&gt;right-&gt;color == RED) {</p><p>                 // 先左再右</p><p>            }</p><p>        }</p><p>        return root;</p><p>    }</p><p>};</p><p>&#x60;&#x60;&#x60;</p><p></p><p></p><p></p><p>(4) 细心的你可能已注意到上面两种情况转换后的所在根结点 P 为**黑色**，如果转换后所在根结点 P 为**红色**呢？</p><p></p><p>看下图：</p><p></p><p>![情况3](https://img-blog.csdn.net/20180925213147974?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p>此时，如果P的父节点为黑色，那就没关系，而如果父节点为红色，就需要回溯到上层的根结点继续调整了。回溯操作就会使代码很复杂，所以有一种自顶向下的方法来将这种情况转为 (3) 中的两种情况：**沿着插入路径**，如果发现**某个结点为黑色而它的两个子结点均为红色**，则将该结点变为红色，它的两个子结点变为黑色：</p><p></p><p>![自顶向下](https://img-blog.csdn.net/20180925213331279?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p>此时，就可以发现结点P和结点X颜色都为红，它需要做右旋操作，**也就是上面坚持要检查结点 P 的左子结点为红色的原因**。</p><p></p><p></p><p></p><p>继续添加到代码中：</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>class rbtree {</p><p>// ...</p><p>private:</p><p>    node* root;</p><p>    node* insert(node* root, int val) {</p><p>        if(root == nullptr)</p><p>            return new node(val);</p><p>        </p><p>        // 先沿路径检查</p><p>        if(root-&gt;color == BLACK </p><p>                &amp;&amp; root-&gt;left &amp;&amp; root-&gt;left-&gt;color == RED </p><p>                &amp;&amp; root-&gt;right &amp;&amp; root-&gt;right-&gt;color == RED) {</p><p>            root-&gt;color = RED;</p><p>            root-&gt;left-&gt;color  = BLACK;</p><p>            root-&gt;right-&gt;color = BLACK;</p><p>        }</p><p>        //... </p><p>    }</p><p>};</p><p>&#x60;&#x60;&#x60;</p><p></p><p></p><p></p><p>这就完成了插入操作了。</p><p></p><p>图来自【STL源码剖析】</p>', 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=754960082,3604772462&fm=26&gp=0.jpg', '14', '红黑树实现', '[\"红黑树\",\"C++\"]', '2019-04-17 10:51:41', '1', '0', '0'), ('40', '跳表实现', '20', '2019-04-17 10:56:52', '9', '0', '<p>## 跳表（skip list）</p><p>* LINDA</p><p>* 2018/8/9</p><p></p><p></p><p>跳表可以作为AVL、红黑树等平衡二叉树或伸展树等自适应树的替代品。</p><p></p><p>对于跳表，任何数据集的查找、插入、删除操作都是&#x60;O(lgn)&#x60;。</p><p></p><p>在普通的链表中，查找、插入、删除都是&#x60;O(n)&#x60;，这是因为它是按顺序扫描的。如果可以增大扫描的步长（即跳过某些结点），我们就可以减少扫描的开销了。这就是跳表的基本思想。</p><p></p><p>跳表相对于普通链表有两点不同：</p><p></p><p>1. 普通链表的结点只有一个&#x60;next&#x60;指针指向下一个结点，跳表的结点有多个&#x60;next&#x60;指针指向多个下个结点（也叫作向前指针（*forward* reference）。）</p><p>2. 对于一个给定的结点，它的向前指针的个数是**随机**的。</p><p></p><p>我们可以说一个跳表的结点是有层数的(&#x60;levels&#x60;)，一层就有一个向前指针。所以，结点的层数被称为是**结点的大小**。</p><p></p><p></p><p></p><p>### 基本思想</p><p></p><p>为了介绍跳表的数据结构，我们先来看下面这三个可以”跳“的表数据结构，但还不是真正的跳表。在遍历过程中，第一个允许跳过一个，第二个允许跳过四个，第三个允许跳过八个结点，如果继续下去，我们就可以得到可以跳过&#x60;2^i&#x60;结点的表结构了。</p><p></p><p>对于跳表，我们知道头结点和其他结点都是不一定有相同的向前指针的。有的有一个，有的有多个。</p><p></p><p>那么，我们先假设它的结点的数据结构是这样的：</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>struct Node {</p><p>    int key;  // 值</p><p>    vector&lt;Node*&gt; next; // 向前指针的集合</p><p>};</p><p>&#x60;&#x60;&#x60;</p><p></p><p>那么，查找操作的例程应该是这样的：</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>Node* find(const int x) {</p><p>    Node* p = head; // 头结点</p><p>    int levels = p-&gt;next.size();</p><p>    if(x &lt; p-&gt;key)</p><p>        return nullptr; // 表示没找到</p><p>    for(int i = 0; i &lt; levels; ++i) {</p><p>        if(p-&gt;next[i]-&gt;key == x) {</p><p>            return p-&gt;next[i];</p><p>        }</p><p>        </p><p>        if(p-&gt;next[i]-&gt;key &gt; x) { // 如果目标值比当前结点值小，查找下一层</p><p>            continue;</p><p>        }</p><p>        </p><p>        if(p-&gt;next[i]-&gt;key &lt; x) { // 如果目标值比当前结点值大，查找该层的下一个结点</p><p>            p = p-&gt;next[i];</p><p>            i = 0;</p><p>            levels = p-&gt;next.size();</p><p>        }</p><p>    }</p><p>    return nullptr; // 查找不到</p><p>}</p><p>&#x60;&#x60;&#x60;</p><p></p><p>我们从头结点的最高层开始，如果目标值比当前结点小，我们就向下一层查找，如果目标值比当前值大，我们就向该层的下一个结点查找，找到则返回该结点，找不到返回空。</p><p></p><p>#### 跳过每两个结点</p><p></p><p>图一表示了一个16结点的链表结构，每两个结点就有两个向前指针，存储值表示在结点下面。头结点有两层，且不能小于最大的结点。&#x60;2&#x60;结点有一个向前指针指向&#x60;4&#x60;结点，相似的有&#x60;4&#x60;，&#x60;6&#x60;，&#x60;8&#x60;，等。每两个就有一个拥有两个向前指针。</p><p></p><p>![Figure1](https://img-blog.csdn.net/20180809182321100?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p>显然，它的查找操作并不需要一个一个结点查找。可以每次都先跳过一个结点，直到无法跳过，再找下一个结点就好了。所以，需要查找的结点不会超过$\\lceil\\frac{n}{2}\\rceil + 1$ 。例如，查找&#x60;15&#x60;，它只需要查找&#x60;2,4,6,8,10,12,14,16,15&#x60;，总共$\\lceil\\frac{16}{2}\\rceil + 1=9$</p><p></p><p>#### 跳过每两个和四个结点</p><p></p><p>第二个例子，就是一个链表的每两个结点能一次向前两个结点，每四个结点能一次向前四个结点，如图2，头结点必须不小于最大（层数）结点（的层数）。</p><p></p><p>![Figure2](https://img-blog.csdn.net/20180809182203589?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p>这样，查找操作就可以以更大的步长来查找了。可以每次跳过四个结点直到无法跳过，在查找接着的最多3个结点。所以，查找的结点不会超过 $\\lceil\\frac{n}{4}\\rceil + 3$。例如，查找&#x60;15&#x60;，它只需要查找&#x60;4,8,12,16,14,16,15&#x60;，总共 $\\lceil\\frac{16}{4}\\rceil + 3=7$ 。</p><p></p><p>#### 跳过每$2^i$个结点</p><p></p><p>这最后一个例子，就是一个允许跳过更大的步长的链表：</p><p></p><p>![Figure3](https://img-blog.csdn.net/20180809181907435?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p>每第$2^i$个结点$i = 1, \\ldots \\lceil \\lg n \\rceil$，就可以向前$2^i$个结点。例如每个第&#x60;2&#x60;结点就可以向前两个结点，每第八个结点就可以向前8个结点，等等。同样的，头结点不能比最大结点小。</p><p></p><p>假设图3的链表拥有32个结点，那么我们要查找一个数，就从头结点的最高层开始，先比较第16个结点，如果比它小则进入前半段查找，如果比它大这进入后半段查找，如此反复，直到查找到，显然，这是一个折半查找，时间复杂度为&#x60;O(lgn)&#x60;。</p><p></p><p>这个数据结构看来已经很完美了，其实，它在插入或删除操作上有很严重的问题。它要求插入一个数或删除一个数后，重新调整好整张表，这个操作的复杂度为&#x60;O(n)&#x60;。</p><p></p><p>所以，真正的跳表就采用了**概率**的方法来操作整张表。一个跳表被要求结点大小要有一致的分布，但不需要固定的结点大小。所以，也就不需要在**删除**或**插入**后做相应的结点调整了。</p><p></p><p></p><p></p><p>#### 跳表——概率的方法</p><p></p><p>图4可以看做是图3的各结点的重新组织。结点大小的分布和图3是一样的，仅仅是位置不同而已。在这个例子中，这种方法要求有一个向前指针的结点有&#x60;50%&#x60;，有两个向前指针的结点有&#x60;25%&#x60;，有三个向前指针的结点有&#x60;12.5%&#x60;，等等。这个分布是固定的，但像图3的严格的按顺序分布则不需要。</p><p></p><p>![Figure4](https://img-blog.csdn.net/20180809181739840?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbmRhX2Rz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</p><p></p><p>图4只是这种概率下的一种可能的情况而已。在满足概率分布的条件下，其他情况也是允许的。</p><p></p><p>当插入一个新值，我们按概率选择一个新结点的大小。每个跳表有一个先确定的概率&#x60;p&#x60;，来决定结点的概率分布。也可以说，拥有&#x60;r&#x60;个向前指针的结点的&#x60;p&#x60;倍的结点数拥有&#x60;r+1&#x60;个向前指针。在一个新结点插入后，跳表不需要再重新组织。</p><p></p><p>#### 结点的分布</p><p></p><p>假设我们有一个给定概率为&#x60;p&#x60;的无限长的跳表。也就是第&#x60;i&#x60;层的结点的&#x60;p&#x60;倍为第&#x60;i+1&#x60;层的结点（和上面同个意思）。设 $L_k$为拥有&#x60;k&#x60;个向前指针的结点数，那么，$L_k = p L_{k-1}$</p><p>并且</p><p>$$</p><p>L_1 = 1 - \\sum_{i=2}^\\infty L_i </p><p>$$</p><p>因为</p><p>$$</p><p>\\sum_{i=2}^\\infty L_i =L_2 + L_3 + \\cdots =L_2 + pL_2 + p^2L_2 +\\cdots</p><p>$$</p><p></p><p></p><p>所以，我们可以这样，</p><p>$$</p><p>L_1 = 1 - L_2 \\sum_{i=0}^\\infty p^i</p><p>$$</p><p>几何级数的和$\\sum_{i=0}^\\infty p^i$可以表示为：</p><p>$$</p><p>\\sum_{i=0}^\\infty p^i = \\frac{1}{1-p}</p><p>$$</p><p>因此，</p><p>$$</p><p>L_1 = 1-\\frac{L_2}{1-p}</p><p>$$</p><p>又因为$L2=p*L1$，所以</p><p>$$</p><p>L_1 = 1 - \\frac{pL_1}{1 - p} \\Rightarrow L_1 = 1 - p </p><p>$$</p><p>在图4的情况，&#x60;p=0.5&#x60;。因此，有&#x60;1-1/2=1/2&#x60;的结点拥有一个向前指针，它的&#x60;1/2&#x60;的结点拥有两个向前指针，等等。</p><p></p><p>#### 选择一个结点概率</p><p></p><p>当我们需要**插入**一个结点时，结点的大小通过一个随机数生成器&#x60;r&#x60;来选取。这是有确定概率&#x60;p&#x60;和最大层数&#x60;maxLevel&#x60;的跳表的一种选择方法：</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>int generateNodeLevel(double p, int maxLevel) {</p><p>    int level = 1;</p><p>    while(drand48() &lt; p) // drand48()产生一个0~1之间的随机数</p><p>        ++level;</p><p>    return (level &gt; maxLevel)? maxLevel : level;</p><p>}</p><p>&#x60;&#x60;&#x60;</p><p></p><p>注意，每个新结点的层数是独立于跳表中已经存在的结点的。每个结点的选择仅仅基于跳表的概率&#x60;p&#x60;。**查找**操作需要比较的平均次数为 </p><p>$$</p><p>1 + \\frac{\\log_\\frac{1}{p} n}{p} + \\frac{1}{1 - p}</p><p>$$</p><p>例如，大小为65536的跳表，在&#x60;p=1/4时，&#x60;平均查找结点数为&#x60;34.3&#x60;，在&#x60;p=1/2&#x60;时，平均查找结点数为&#x60;35&#x60;，这比相同的普通链表的平均查找次数&#x60;n/2=32768&#x60;要好很多。</p><p></p><p>#### 头结点的层数</p><p></p><p>头结点的层数是整个跳表被允许的最大的层数。*Pugh*(跳表的发明者) 认为最大的层数应该被设为 $\\log_\\frac{1}{p} n$。因此，对于$p=\\frac{1}{2}$，拥有最多65536个元素的跳表的最大高度应该不小于$\\lg_2 65536 = 16$。</p><p></p><p>#### 关于性能的思考</p><p></p><p>查找一个元素（或插入、删除）的期望时间是&#x60;O(lgn)&#x60;。有时候，如果结点的层数分布不好，将会导致某个操作的时间增加。因为结点的大小是随机生成的，它可能会产生一个不好的大小值。例如，它可能对每个结点都生成相同的大小，这就等价于生成了一个普通链表。一个不好的大小值将导致比期望时间大的查找（插入或删除）时间。显然，一个不好的大小值将和跳表的长度成反比，也就是随着结点数的增加，性能会逐步增加。</p><p></p><p>一个操作的时间将会比期望的时间长的概率是和跳表相关的概率&#x60;p&#x60;有函数关系的。例如，*Pugh* 计算过一个&#x60;p = 0.5&#x60;，拥有4096个元素的跳表，实际时间超过期望时间的3倍的概率小于2亿分之一。</p><p></p><p>跳表相关的时间和空间性能依赖于这个表的层数的概率。*Push* 建议更多情况下使用&#x60;p=0.25&#x60;。如果性能伸缩更重要的，它建议使用&#x60;p=0.5&#x60;（伸缩性随着概率的增加而减少）。有趣的是，当&#x60;p=0.25&#x60;时，每个结点的向前指针平均值为1.33，而一个平衡二叉树，每个结点需要两个指针，所以，**跳表可能更节省空间**。</p><p></p><p></p><p></p><p>### 跳表的实现</p><p></p><p>&#x60;&#x60;&#x60;c++</p><p>template &lt;class Comparable&gt;</p><p>class SkipList {</p><p>private:</p><p>   class SkipListNode {</p><p>	   public:</p><p>	       void setDatum(const Comparable &amp; datum); // 设置数据</p><p>	       void setForward(int i, SkipListNode* f); // 设置向前指针</p><p>	       void setSize(int sz); // 设置大小</p><p>	       SkipListNode();</p><p>	       SkipListNode(const Comparable&amp; datum, int levels);</p><p>	       SkipListNode(const SkipListNode&amp; );</p><p>	       ~SkipListNode();</p><p>	   </p><p>	       const Comparable&amp; getDatum() const;</p><p>	       int getSize() const;</p><p>	       SkipListNode * getForword(int level);</p><p>	   private:</p><p>	       int _levels; // 该结点的层数</p><p>	       vector&lt;SkipListNode* &gt; _forward; // 向前指针</p><p>	       Comparable _datum; // 数据</p><p>   }; // SkipListNode</p><p>public:</p><p>   SkipList(); // max_node_size=16, probab=0.25</p><p>   SkipList(int max_node_size, double probab);</p><p>   SkipList(const SkipList &amp;);</p><p>   ~SkipList();</p><p>   </p><p>   int getHighNodeSize() const; // 获取当前跳表的最大结点的最高层</p><p>   int getMaxNodeSize() const; // 获取该跳表允许的最大结点大小</p><p>   double getProbability() const; // 获取概率</p><p>   // 插入</p><p>   void insert(const Comparable&amp; item);</p><p>   </p><p>   // 查找，如果找到，返回该项，并设&#x60;success&#x60;为true，失败，返回空项，success为false</p><p>   const Comparable&amp; find(const Comparable&amp; item, bool&amp; success);</p><p>   // 删除</p><p>   void remove(const Comparable&amp; item);</p><p>private:</p><p>   // 查找，从&#x60;startnode&#x60;开始，通常是header，如果找到，返回结点，否则返回前一个结点。前提条件：startnode非空。</p><p>   SkipListNode* find(const Comparable&amp; item, SkipListNode* startnode);</p><p>   SkipListNode* getHeader() const;</p><p>   </p><p>   SkipListNode *findInsertPoint(const Comparable&amp; item, int nodesize);</p><p>   void insert(const Comparable&amp; item, int nodesize, bool&amp; success);</p><p>   int _high_node_size; // 当前跳表中最大结点的层数</p><p>   int _max_node_size; // 跳表允许的最大层数</p><p>   double _prob; // 概率</p><p>   SkipListNode* _head; // 头结点</p><p>}; // SkipList</p><p>&#x60;&#x60;&#x60;</p><p></p><p>具体实现后续放上。</p><p></p><p></p><p></p><p>翻译自（有部分改动）</p><p></p><p>[Skip Lists](https://www.csee.umbc.edu/courses/undergraduate/341/fall01/Lectures/SkipLists/skip_lists/skip_lists.html)</p>', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556207168230&di=4f8d1f3ebb77d420b2d70d5fac36bbf2&imgtype=0&src=http%3A%2F%2Fwww.aboutyun.com%2Fdata%2Fattachment%2Fforum%2F201505%2F25%2F202605b8vo6jv6f666vj00.png', '14', '跳表', '[\"C++\",\"跳表\"]', '2019-04-17 10:56:41', '1', '0', '0');
INSERT INTO `articles` VALUES ('41', '漫威十年观影顺序', '17', '2019-05-06 17:51:33', '27', '1', '<p></p><div class=\"media-wrap image-wrap\"><img src=\"/server/static/302931504@qq.com/article/3e4e198aac2d1.jpeg\"/></div><p></p><p><span style=\"letter-spacing:1px\"><span style=\"line-height:1.5\">漫威电影观看顺序第一阶段：《钢铁侠》，《无敌浩克》，《钢铁侠2》，《雷神》，《美国队长》，《复仇者联盟》</span></span></p><p><span style=\"letter-spacing:1px\"><span style=\"line-height:1.5\">漫威电影观看顺序第二阶段：《钢铁侠3》，《雷神2》，《美国队长2》，《银河护卫队》，《复仇者联盟2：奥创纪元》，《蚁人》</span></span></p><p><span style=\"letter-spacing:1px\"><span style=\"line-height:1.5\">漫威电影观看顺序第三阶段：《美国队长3：英雄内战》，《奇异博士》，《银河护卫队2》，《蜘蛛侠：英雄归来》，《雷神3：诸神的黄昏》，《黑豹》</span></span></p>', '', '11', '最近跟小可爱看了 惊队 跟 妇联4， 现在想回补一下漫威之前的电影，就简单的记一下我接下来该看啥～', '[\"漫威\"]', '2019-05-06 17:51:27', '1', '2', '1'), ('42', 'ES6特性总结(一)', '17', '2019-05-28 17:57:57', '14', '0', '<h1 style=\"text-align:start;\">let &amp; const</h1><p></p><p style=\"text-align:start;\"><strong>es6</strong>新增了<em>let</em>和<em>const</em>两个命令来取代<em>var</em>；</p><p></p><h2 style=\"text-align:start;\">var</h2><p></p><p style=\"text-align:start;\"><em>var</em>定义变量时会存在变量提升，如下：</p><pre><code><strong><span style=\"color:#333333\">var</span></strong> a = <span style=\"color:#008080\">123</span>;  <br/><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">f</span></strong>() {  <br/>  <span style=\"color:#0086b3\">console</span>.log(a);  <em><span style=\"color:#999988\">//undefined</span></em><br/>  <strong><span style=\"color:#333333\">var</span></strong> a = <span style=\"color:#008080\">456</span>;  <br/>};</code></pre><p style=\"text-align:start;\"><em>var</em>声明的变量提升只会提升变量名而不会提升值；<br/><em>function</em>定义的函数同样会提升但是提升的是整个函数体；</p><p></p><h2 style=\"text-align:start;\">let</h2><p></p><p style=\"text-align:start;\"><em>let</em>声明变量不会提升，而且不能用<em>let</em>重复声明同一个变量，否则会报错；<em>let</em>会产生一个块级作用域，如下：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">f2</span></strong> () {  <br/>  <strong><span style=\"color:#333333\">let</span></strong> a = <span style=\"color:#008080\">1</span>;<br/>  <strong><span style=\"color:#333333\">if</span></strong> (<span style=\"color:#008080\">true</span>) {  <br/>    <strong><span style=\"color:#333333\">let</span></strong> a = <span style=\"color:#008080\">2</span>;<br/>  }  <br/>  <span style=\"color:#0086b3\">console</span>.log(a); <em><span style=\"color:#999988\">// 1</span></em><br/>};</code></pre><p style=\"text-align:start;\">f2函数内又两个代码块，代码块里都声明了变量a，外层代码块不受内层代码块的影响，如果使用的是<em>var</em>声明变量，那么打印结果为2；</p><p></p><p style=\"text-align:start;\"><strong>暂时性死区</strong>：只要<em>let</em>存在块级作用域，它就会绑定这个作用域，如：</p><pre><code><strong><span style=\"color:#333333\">let</span></strong> a = <span style=\"color:#008080\">123</span>;  <br/><strong><span style=\"color:#333333\">if</span></strong> (<span style=\"color:#008080\">true</span>) {  <br/>  a = <span style=\"color:#008080\">456</span>;  //ReferenceError<br/>  <strong><span style=\"color:#333333\">let</span></strong> a;<br/>}</code></pre><p style=\"text-align:start;\">上面全局作用域声明了一个变量a，然后在if语句里的第二行也声明了a，此时a绑定在if的代码块内，在给a赋值时不是给全局的a赋值，而是给if中的a赋，a不会提升，所以上面报错就是因为给没有声明的变量赋值；</p><p></p><p></p><h2 style=\"text-align:start;\">const</h2><p></p><p style=\"text-align:start;\"><em>const</em>用来声明一个只读常量，若改变一个由<em>const</em>声明切赋值的常量的值会报错；如果const声明的是一个引用类型值，如一个对象，就可以改变这个对象内部的属性的值，只要保证该对象的内存地址不变。</p><p></p><p></p><h1 style=\"text-align:start;\">变量的解构赋值</h1><p></p><p style=\"text-align:start;\">结构赋值用一种更简单的方式从一个数组或对象中分离出来值，如：</p><p><br/>1.从数组中解构赋值：</p><pre><code>let [a,b,c] = [<span style=\"color:#008080\">1</span>,<span style=\"color:#008080\">2</span>,<span style=\"color:#008080\">3</span>,<span style=\"color:#008080\">4</span>];<br/>a <em><span style=\"color:#999988\">// 1</span></em><br/>b <em><span style=\"color:#999988\">// 2</span></em><br/>c <em><span style=\"color:#999988\">// 3  </span></em><br/>let [a,b,c] = [<span style=\"color:#008080\">1</span>,<span style=\"color:#008080\">2</span>];<br/>a <em><span style=\"color:#999988\">// 1</span></em><br/>b <em><span style=\"color:#999988\">// 2</span></em><br/>c <em><span style=\"color:#999988\">// undefined</span></em></code></pre><p style=\"text-align:start;\"></p><p>2.从对象中解构赋值 。</p><pre><code>let {<span style=\"color:#dd1144\">a:</span> c, b} = {<span style=\"color:#dd1144\">a:</span> <span style=\"color:#008080\">1</span>, <span style=\"color:#dd1144\">b:</span> <span style=\"color:#008080\">2</span>};<br/>a <em><span style=\"color:#999988\">// 1</span></em><br/>b <em><span style=\"color:#999988\">// 2 </span></em><br/>c <em><span style=\"color:#999988\">// 1</span></em></code></pre><p style=\"text-align:start;\">解构赋值支持默认值，若不能从数组或对象等中解构出值就是默认值：</p><pre><code>let [a = <span style=\"color:#008080\">1</span>] = [];<br/>a <em><span style=\"color:#999988\">// 1</span></em><br/>let [b = <span style=\"color:#008080\">2</span>] = [<span style=\"color:#008080\">3</span>];<br/>b <em><span style=\"color:#999988\">// 3</span></em></code></pre><p></p><p></p><h1 style=\"text-align:start;\">字符串扩展</h1><p></p><p style=\"text-align:start;\">1.新增<em>includes</em>、<em>startsWith</em>、<em>endsWith</em></p><pre><code><strong><span style=\"color:#333333\">const</span></strong> <span style=\"color:#0086b3\">str</span> = <span style=\"color:#dd1144\">&#x27;hello world&#x27;</span>;  <br/><span style=\"color:#0086b3\">str</span>.includes(<span style=\"color:#dd1144\">&#x27;llo&#x27;</span>); <em><span style=\"color:#999988\">// true</span></em><br/><span style=\"color:#0086b3\">str</span>.startsWith(<span style=\"color:#dd1144\">&#x27;hello&#x27;</span>); <em><span style=\"color:#999988\">// true  </span></em><br/><span style=\"color:#0086b3\">str</span>.endsWith(<span style=\"color:#dd1144\">&#x27;d&#x27;</span>); <em><span style=\"color:#999988\">// true</span></em></code></pre><p style=\"text-align:start;\">这三个方法支持传入第二个参数，指定从字符串的哪个位置开始：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> <span style=\"color:#0086b3\">str</span> = <span style=\"color:#dd1144\">&#x27;hello world&#x27;</span>;  <br/><span style=\"color:#0086b3\">str</span>.includes(<span style=\"color:#dd1144\">&#x27;llo&#x27;</span>, <span style=\"color:#008080\">1</span>); <em><span style=\"color:#999988\">// true</span></em><br/><span style=\"color:#0086b3\">str</span>.startsWith(<span style=\"color:#dd1144\">&#x27;hello&#x27;</span>, <span style=\"color:#008080\">2</span>); <em><span style=\"color:#999988\">// false  </span></em><br/><span style=\"color:#0086b3\">str</span>.endsWith(<span style=\"color:#dd1144\">&#x27;d&#x27;</span>, <span style=\"color:#008080\">4</span>); <em><span style=\"color:#999988\">// true</span></em></code></pre><p></p><p style=\"text-align:start;\">2.<em>repeat</em>方法</p><pre><code><span style=\"color:#dd1144\">&#x27;x&#x27;</span>.<strong><span style=\"color:#333333\">repeat</span></strong><em><span style=\"color:#999988\">(3)</span></em>; <em><span style=\"color:#999988\">// xxx  </span></em><br/><span style=\"color:#dd1144\">&#x27;hello&#x27;</span>.<strong><span style=\"color:#333333\">repeat</span></strong><em><span style=\"color:#999988\">(2)</span></em>; <em><span style=\"color:#999988\">//hellohello</span></em></code></pre><ul><li style=\"text-align:start;\">输入参数是小于（-1）或为Infinity的参数会报错 ·参数介于0～-1之间为0</li><li>参数为NaN为0</li><li>参数是字符串先转换为数字</li></ul><p style=\"text-align:start;\">3.<em>padStrat</em>、<em>padEnd</em></p><pre><code><span style=\"color:#990073\">&#x27;x&#x27;.padStrat</span>(<span style=\"color:#000080\">5</span>, <span style=\"color:#990073\">&#x27;ab</span>&#x27;)<em><span style=\"color:#999988\">; // ababx  </span></em><br/><span style=\"color:#990073\">&#x27;x&#x27;.padStrat</span>(<span style=\"color:#000080\">4</span>, <span style=\"color:#990073\">&#x27;ab</span>&#x27;)<em><span style=\"color:#999988\">; // abax</span></em><br/><span style=\"color:#990073\">&#x27;x&#x27;.padEnd</span>(<span style=\"color:#000080\">4</span>, <span style=\"color:#990073\">&#x27;ab</span>&#x27;)<em><span style=\"color:#999988\">; // xaba</span></em></code></pre><ul><li style=\"text-align:start;\">字符串够长则忽略该方法</li><li>不传入第二个参数则以空格补齐</li></ul><p></p><h1 style=\"text-align:start;\">函数的扩展</h1><p></p><h2 style=\"text-align:start;\">1.函数参数设置默认值</h2><p></p><p style=\"text-align:start;\">ES5不能直接指定传入参数的默认值，只能这样变通：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">f4</span></strong> (aa, bb) {  <br/>  aa = aa || <span style=\"color:#dd1144\">&#x27;hello&#x27;</span>;<br/>  bb = bb || <span style=\"color:#dd1144\">&#x27;world&#x27;</span>;<br/>  <strong><span style=\"color:#333333\">return</span></strong> aa + <span style=\"color:#dd1144\">&#x27;&#x27;</span> + bb;<br/>};</code></pre><p style=\"text-align:start;\">现在我们可以这样：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">f4</span></strong> (aa = <span style=\"color:#dd1144\">&#x27;hello&#x27;</span>, bb = <span style=\"color:#dd1144\">&#x27;world&#x27;</span>) {  <br/>   <strong><span style=\"color:#333333\">return</span></strong> <span style=\"color:#dd1144\">&#x60;<span style=\"color:#333333\">${a}</span> <span style=\"color:#333333\">${b}</span>&#x60;</span>;<br/> };</code></pre><ul><li style=\"text-align:start;\">传入的参数不能有重复</li><li>传入的参数不能用<em>let</em>和<em>const</em>重新声明</li><li>传入的参数是惰性求值的</li><li>指定默认参数后函数的<strong>length</strong>属性将失真，等于没有赋默认值的参数个数 。 ·函数初始化时，参数会单独形成一个作用域，初始化结束作用域便消失</li></ul><p></p><h2 style=\"text-align:start;\">2.函数的reset参数</h2><p></p><p style=\"text-align:start;\">reset参数(...变量名)，reset搭配的变量是一个数组，用于获取多个参数，可以取代函数里的arguments属性，如：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">f5</span></strong> (...values) {  <br/>  <strong><span style=\"color:#333333\">for</span></strong> (let arg of values) {  <br/>    console.log(arg);<br/>  }<br/>};  <br/>f5(<span style=\"color:#008080\">1</span>,<span style=\"color:#008080\">2</span>,<span style=\"color:#008080\">3</span>); <em><span style=\"color:#999988\">//1 2 3</span></em></code></pre><p style=\"text-align:start;\">因为arguments是一个类数组的属性，所以不能直接使用数组的方法，一下一个列子：</p><pre><code><em><span style=\"color:#999988\">//ES5  </span></em><br/><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">sortNumbers</span></strong> () {  <br/>  <strong><span style=\"color:#333333\">return</span></strong> <span style=\"color:#0086b3\">Array</span>.prototype.slice(<span style=\"color:#0086b3\">arguments</span>).sort();<br/>};  <br/>  <br/><em><span style=\"color:#999988\">//ES6  </span></em><br/>sortNumbers = (...values) =&gt; {  <br/>  <strong><span style=\"color:#333333\">return</span></strong> values.sort(); <br/>};</code></pre><p></p><h2 style=\"text-align:start;\">3.钩子函数</h2><p></p><p style=\"text-align:start;\">如下格式：</p><pre><code>let f5 = (<strong><span style=\"color:#333333\">param</span></strong>1, <strong><span style=\"color:#333333\">param</span></strong>2) =&gt; {  <br/>  <strong><span style=\"color:#333333\">return</span></strong> <strong><span style=\"color:#333333\">param</span></strong>1 + <strong><span style=\"color:#333333\">param</span></strong>2;<br/>};  <br/><br/>//等同于  <br/><br/>let f5 = <strong><span style=\"color:#333333\">function</span></strong> (<strong><span style=\"color:#333333\">param</span></strong>1, <strong><span style=\"color:#333333\">param</span></strong>2) {  <br/>  <strong><span style=\"color:#333333\">return</span></strong> <strong><span style=\"color:#333333\">param</span></strong>1 + <strong><span style=\"color:#333333\">param</span></strong>2;<br/>};</code></pre><p style=\"text-align:start;\">钩子函数的好处是不改变this的值，this依旧是指向定义时的对象，一下列子来说明钩子函数的好处：</p><pre><code><strong><span style=\"color:#333333\">let</span></strong> name = <span style=\"color:#dd1144\">&quot;wangsi&quot;</span>;<br/><strong><span style=\"color:#333333\">let</span></strong> f6 = <strong><span style=\"color:#333333\">function</span></strong> () {  <br/>  <strong><span style=\"color:#333333\">let</span></strong> name = <span style=\"color:#dd1144\">&quot;zhangsan&quot;</span>;<br/>  setTimeout(<strong><span style=\"color:#333333\">function</span></strong> () {  <br/>    <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&quot;my name is&quot;</span>: <strong><span style=\"color:#333333\">this</span></strong>.name);<br/>  }， <span style=\"color:#008080\">1000</span>);<br/>}   <br/><em><span style=\"color:#999988\">//  调用f5时将输出my name is wangsi,  </span></em><br/><em><span style=\"color:#999988\">//  因为setTimeout中的this指向的是window而f6，若要指向f6可以这样改：  </span></em><br/><strong><span style=\"color:#333333\">let</span></strong> f6 = <strong><span style=\"color:#333333\">function</span></strong> () {  <br/>  <strong><span style=\"color:#333333\">let</span></strong> name = <span style=\"color:#dd1144\">&quot;zhangsan&quot;</span>;<br/>  <strong><span style=\"color:#333333\">let</span></strong> _this = <strong><span style=\"color:#333333\">this</span></strong>;<br/>  setTimeout(<strong><span style=\"color:#333333\">function</span></strong> () {  <br/>    <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&quot;my name is&quot;</span>: _this.name);<br/>  }， <span style=\"color:#008080\">1000</span>);<br/>}  <br/><em><span style=\"color:#999988\">//使用钩子函数重构这个函数  </span></em><br/><strong><span style=\"color:#333333\">let</span></strong> f6 = funtion () {  <br/>  <strong><span style=\"color:#333333\">let</span></strong> name = <span style=\"color:#dd1144\">&quot;zhangsan&quot;</span>;<br/>  setTimeout(() =&gt; <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&quot;my name is&quot;</span>: <strong><span style=\"color:#333333\">this</span></strong>.name)， <span style=\"color:#008080\">1000</span>); <em><span style=\"color:#999988\">//  my name is zhangsan</span></em><br/>};</code></pre><p><span style=\"color:#24292e\"><span style=\"font-size:14px\">这样对比上面第二个函数和第三个函数就能看出钩子函数的有点；</span></span></p><p></p><p><strong>注意：</strong></p><ul><li><span style=\"color:#24292e\"><span style=\"font-size:14px\">钩子函数不能当作构造函数，不能用new操作符，否则会报错</span></span></li><li><span style=\"color:#24292e\"><span style=\"font-size:14px\">钩子函数里不存在arguments对象</span></span></li><li><span style=\"color:#24292e\"><span style=\"font-size:14px\">不能用作Generator函数</span></span></li></ul><h1 style=\"text-align:start;text-indent:2em;\"></h1><h1>数组的扩展</h1><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>1.扩展运算符(...)</h2><p></p><p style=\"text-align:start;\">扩展运算符就好比reset参数的逆运算，把一个数组转换为以逗号分割的参数序列；<br/>扩展运算符可以用于复制数组，如：</p><pre><code><strong><span style=\"color:#333333\">let</span></strong> arr1 = [<span style=\"color:#008080\">1</span>,<span style=\"color:#008080\">2</span>,<span style=\"color:#008080\">3</span>,<span style=\"color:#008080\">4</span>];  <br/><strong><span style=\"color:#333333\">let</span></strong> arr2 = [...arr1];  <em><span style=\"color:#999988\">// 写法一</span></em><br/><strong><span style=\"color:#333333\">let</span></strong> [...arr3] = arr1;  <em><span style=\"color:#999988\">// 写法二</span></em></code></pre><p style=\"text-align:start;\">不能直接把arr1赋值给arr2，这样只是把arr1的指针复制给数组了，arr2和arr1指向同一个数组；</p><p></p><h2 style=\"text-align:start;\">2.Array.form()</h2><p></p><p style=\"text-align:start;\">此方法可以把一个<em>类数组对象</em>或者一个<em>可遍历对象</em>转化为一个真正的数组；<br/>·<em><strong>类数组对象</strong></em>：必须含有length 属性，常见的有函数体内的arguments对象和DOM操作返回的NodeList对象；<br/>·<em><strong>可遍历对象</strong></em>：包括ES6中的Map和Set，Object是不可遍历的；<br/>Array.form()接受第二个参数，这个参数是一个函数，返回对每一个元素操作后的结果并保存在数组中；</p><p></p><h2 style=\"text-align:start;\">3.<em>keys()</em>、<em>values()</em>、<em>entries()</em></h2><p></p><p style=\"text-align:start;\">这三个方法返回可被 for..of 遍历的遍历器对象，keys()返回键，values返回值，entries() 返回键值对；</p><p></p><h2 style=\"text-align:start;\">4.对空位的操作</h2><ul><li><em>forEach()</em>, <em>filter()</em>, <em>reduce()</em>, <em>every()</em> 和 *some()*都会跳过空位。</li><li>*map()*会跳过空位，但会保留这个值</li><li>*join()<em>和</em>toString()*会将空位视为undefined，而undefined和null会被处理成空字符串。</li></ul><p></p><p></p><h1 style=\"text-align:start;\">对象的扩展</h1><p></p><h2 style=\"text-align:start;\"><a href=\"http://1.object.is/\" target=\"_blank\">1.Object.is</a>()</h2><p></p><p style=\"text-align:start;\">在ES5严格模式中，&#x27;===&#x27;下&#x27;NaN&#x27;不等于自身，&#x27;-0&#x27;和&#x27;+0&#x27;相等，使用*<a href=\"http://object.is/\" target=\"_blank\">Object.is</a>()*如下：</p><pre><code><span style=\"color:#0086b3\">Object</span>.<strong><span style=\"color:#333333\">is</span></strong>(NaN, NaN); <em><span style=\"color:#999988\">//true</span></em><br/><span style=\"color:#0086b3\">Object</span>.<strong><span style=\"color:#333333\">is</span></strong>(<span style=\"color:#008080\">-0</span>, +<span style=\"color:#008080\">0</span>); <em><span style=\"color:#999988\">//false</span></em></code></pre><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>2.Object.assign()</h2><p style=\"text-align:start;text-indent:2em;\"></p><p><em>Object.assign</em>用于合并数组，第一个参数是目标对象，后面的参数都是源对象：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> <strong><span style=\"color:#333333\">target</span></strong> = {a: 1};<br/><strong><span style=\"color:#333333\">const</span></strong> source1 = {b: 2};<br/><strong><span style=\"color:#333333\">const</span></strong> source2 = {c: 3};<br/>Object.assign(<strong><span style=\"color:#333333\">target</span></strong>, source1, source2); <em><span style=\"color:#999988\">// {a: 1, b: 2, c: 3}</span></em></code></pre><ul><li>传入null或undefined会报错</li><li>执行浅拷贝，即目标对象得到的是源对象的引用</li></ul><h2 style=\"text-align:start;\">3.描述对象(Descriptor)</h2><p style=\"text-align:start;text-indent:2em;\"></p><p>每个对象的属性都有一个描述对象来控制该属性的表现，可用<em>Object.getOwnPropertyDescriptor</em>方法可以获取该属性的描述对象；</p><pre><code><span style=\"color:#dd1144\">let</span> <span style=\"color:#dd1144\">obj</span> <span style=\"color:#dd1144\">=</span> <span style=\"color:#dd1144\">{</span> foo: <span style=\"color:#008080\">123</span> <span style=\"color:#dd1144\">};</span><br/><span style=\"color:#dd1144\">Object.getOwnPropertyDescriptor(obj,</span> <span style=\"color:#dd1144\">&#x27;foo&#x27;)</span><br/><span style=\"color:#dd1144\">//</span>  <span style=\"color:#dd1144\">{</span><br/><span style=\"color:#dd1144\">//</span>    value: <span style=\"color:#008080\">123</span><span style=\"color:#dd1144\">,</span>  <span style=\"color:#dd1144\">属性的值</span><br/><span style=\"color:#dd1144\">//</span>    writable: <span style=\"color:#008080\">true</span><span style=\"color:#dd1144\">,</span> <span style=\"color:#dd1144\">是否可写</span><br/><span style=\"color:#dd1144\">//</span>    enumerable: <span style=\"color:#008080\">true</span><span style=\"color:#dd1144\">,</span> <span style=\"color:#dd1144\">是否可枚举</span><br/><span style=\"color:#dd1144\">//</span>    configurable: <span style=\"color:#008080\">true</span>  <span style=\"color:#dd1144\">是否能被DELETE删除</span><br/><span style=\"color:#dd1144\">//</span>  <span style=\"color:#dd1144\">}</span></code></pre><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>4.Object.getPrototypeOf() &amp; Object.setPrototypeOf()</h2><p style=\"text-align:start;text-indent:2em;\"></p><p>*Object.getPrototypeOf()*用于取得一个对象的原型对象；<br/>*Object.setPrototypeOf()*更改一个对象的原型对象；<br/><em>super</em>关键字指向当前对象的原型对象；</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> proto = {<br/>  foo: <span style=\"color:#dd1144\">&#x27;hello&#x27;</span><br/>};<br/><br/><strong><span style=\"color:#333333\">const</span></strong> obj = {<br/>  foo: <span style=\"color:#dd1144\">&#x27;world&#x27;</span>,<br/>  <span style=\"color:#0086b3\">find</span>() {<br/>    <span style=\"color:#0086b3\">return</span> super.foo;<br/>  }<br/>};<br/><br/>Object.setPrototypeOf(obj, proto);<br/>obj.<span style=\"color:#0086b3\">find</span>() <em><span style=\"color:#999988\">// &quot;hello&quot;</span></em></code></pre><p></p><p></p><h1 style=\"text-align:start;\">Symbol</h1><p style=\"text-align:start;text-indent:2em;\"></p><p>ES5中有5中基本类型值(<em>Boolean</em>, <em>Number</em>, <em>String</em>, <em>null</em>, <em>undefined</em>)和一种引用类型值(<em>Object</em>)，<em>Symbol</em>作为第7中数据类型被ES6加入表示一个独一无二的值；</p><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>1.Symbol的使用</h2><p style=\"text-align:start;text-indent:2em;\"></p><p>定义一个<em>Symbol</em>使用Symbol函数：</p><pre><code><strong><span style=\"color:#333333\">let</span></strong> s = <span style=\"color:#0086b3\">Symbol</span>(); <br/><br/><strong><span style=\"color:#333333\">typeof</span></strong> s; <em><span style=\"color:#999988\">// &quot;symbol&quot;</span></em></code></pre><p style=\"text-align:start;\">可以为<em>Symbol</em>函数传入值，方便在控制台打印时表示不同的值：</p><pre><code><strong><span style=\"color:#333333\">let</span></strong> s1 = <span style=\"color:#0086b3\">Symbol</span>(<span style=\"color:#dd1144\">&#x27;s1&#x27;</span>);<br/><strong><span style=\"color:#333333\">let</span></strong> s2 = <span style=\"color:#0086b3\">Symbol</span>(<span style=\"color:#dd1144\">&#x27;s2&#x27;</span>);<br/><br/><span style=\"color:#0086b3\">console</span>.log(s1); <em><span style=\"color:#999988\">// Symbol(s1)</span></em><br/><span style=\"color:#0086b3\">console</span>.log(s2); <em><span style=\"color:#999988\">// Symbol(s2)</span></em></code></pre><p style=\"text-align:start;\">Symbol值不与其他值计算，但可以通过toString方法显示的转化为字符串，也可以转化为布尔值；<br/>Symbol值可以作为一个对象的属性名，以防止属性重名，但是作为属性名时不能用&#x27;.&#x27;访问，只能用&#x27;[]&#x27;包起来：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> mySymbol = <span style=\"color:#0086b3\">Symbol</span>();<br/><strong><span style=\"color:#333333\">const</span></strong> a = {};<br/><br/>a.mySymbol = <span style=\"color:#dd1144\">&#x27;Hello!&#x27;</span>;<br/>a[mySymbol] <em><span style=\"color:#999988\">// undefined</span></em><br/>a[<span style=\"color:#dd1144\">&#x27;mySymbol&#x27;</span>] <em><span style=\"color:#999988\">// &quot;Hello!&quot;</span></em></code></pre><p style=\"text-align:start;\">以Symbol为属性名的属性不能被 for...in,for...of等枚举出来，可以用*Object.getOwnPropertySymbols()*方法来获取一个对象中所有以Symbol值作为属性名的属性，返回一个数组；</p><p></p><h2 style=\"text-align:start;\">2.Symbol.for() &amp; Symbol.keyFor()</h2><p style=\"text-align:start;text-indent:2em;\"></p><p><em>Symbol.for()</em>: 往Symbol.for()中传入一个字符串参数，搜索是否存在次Symbol值，存在则返回，不存在就创建一个并返回，这个可以用来把同一个Symbol值赋值给不同变量；<br/><em>Symbol.keyFor()</em>：用于输出使用*Symbol.for()*登记过的Symbol值的key：</p><pre><code>let s1 = <span style=\"color:#0086b3\">Symbol</span>.<strong><span style=\"color:#333333\">for</span></strong>(<span style=\"color:#dd1144\">&#x27;s1&#x27;</span>);<br/><span style=\"color:#0086b3\">Symbol</span>.keyFor(s1); <em><span style=\"color:#999988\">// &#x27;s1&#x27;</span></em></code></pre><ul><li>可以往Symbol()中传入不同的字符串来表示不同的Symbol值，通过控制台打印出容易区分</li><li>就算往Symbol()中传入的参数相同，它们仍然是不同的Symbol值</li><li>可以通过String()、toString()方法来显示的把Symbol值转换为字符串</li></ul>', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1559047543656&di=1d78032fdc6c161f0c046cf01f1936e9&imgtype=0&src=http%3A%2F%2Fimg.mukewang.com%2F590064e6000159e210060572.jpg', '12', '这篇文章主要写了es6的一些基础特性，包括let和const命令，解构赋值，字符串、函数、对象的一些扩展，还包括新引入的一种数据类型Symbol来表示独一无二的值', '[\"es6\",\"只是进阶\"]', '2019-05-28 17:57:57', '1', '0', '0'), ('43', 'ES6特性总结(二)', '17', '2019-05-28 18:10:27', '41', '2', '<h1 style=\"text-align:start;\">Set</h1><p style=\"text-align:start;text-indent:2em;\"></p><p>Set数据结构类似于数组，但元素是不重复的；本身是一个构造函数，所以声明一个Set数据结构要用new操作符：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> s = <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">Set</span>();  <br/>[<span style=\"color:#008080\">2</span>, <span style=\"color:#008080\">3</span>, <span style=\"color:#008080\">5</span>, <span style=\"color:#008080\">4</span>, <span style=\"color:#008080\">5</span>, <span style=\"color:#008080\">2</span>, <span style=\"color:#008080\">2</span>].forEach(x =&gt; s.add(x));<br/><br/><strong><span style=\"color:#333333\">for</span></strong> (<strong><span style=\"color:#333333\">let</span></strong> i <strong><span style=\"color:#333333\">of</span></strong> s) {<br/>  <span style=\"color:#0086b3\">console</span>.log(i);<br/>}<br/><em><span style=\"color:#999988\">// 2,3,5,4</span></em></code></pre><p style=\"text-align:start;\">Set构造函数接收一个数组或者其他可遍历的数据结构为参数：</p><pre><code>const s2 = new Set([<span style=\"color:#008080\">1</span>,<span style=\"color:#008080\">1</span>,<span style=\"color:#008080\">2</span>,<span style=\"color:#008080\">2</span>,<span style=\"color:#008080\">3</span>,<span style=\"color:#008080\">3</span>]); <br/>s2 <em><span style=\"color:#999988\">// 1,2,3</span></em></code></pre><p style=\"text-align:start;\">向Set()中加入值的时候不会发生类型转换，比如 5 不等于 &quot;5&quot;，Set()中对圆的比较是用的“Same-value-zero equality”算法，类似于“=”，但NaN于自身是相等的，而“=”中NaN不等于自身；<br/>向 Set()中传入的对象总是不相等的；</p><p></p><h2 style=\"text-align:start;\">Set实例属性和方法</h2><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>1.属性</h3><pre><code>Set.prototype.constructor <em><span style=\"color:#999988\">// Set</span></em><br/>Set.prototype.size <em><span style=\"color:#999988\">// Set实例中元素的个数</span></em></code></pre><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>2. 方法</h3><ul><li>add(value) // 添加某个值进Set实例</li><li>has(value) // 判断某个值是否在实例中</li><li>delete(value) // 删除某个值</li><li>clear()清除所有与元素</li><li>keys(); //返回键名的遍历器</li><li>values(); // 返回值的遍历器</li><li>entries(); //返回键值对的遍历器</li><li>forEach(); //遍历每一个元素</li></ul><p></p><h1 style=\"text-align:start;\">weakSet</h1><p style=\"text-align:start;text-indent:2em;\"></p><p>weakSet与Set数据结构类似，只是weakSet的成员只能是对象，而且weakSet中都是对对象的弱引用，即当其他对象不再引用该对象时垃圾回收会回收该对象而不考虑weakSet是否引用着该对象，因此不会造成内存泄漏；</p><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2><span style=\"font-size:20px\">1.语法</span></h2><pre><code><strong><span style=\"color:#333333\">const</span></strong> ws = <strong><span style=\"color:#333333\">new</span></strong> weakSet();</code></pre><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2><span style=\"font-size:20px\">2.方法</span></h2><ul><li>has(value) // 判断是否存在某个值</li><li>delete(value) // 删除某个值</li><li>add(value) // 添加某个值</li></ul><p></p><h1 style=\"text-align:start;\">Map</h1><p style=\"text-align:start;text-indent:2em;\"></p><p>js中对象就是键值对的集合(哈希表),但是对象中的键只支持String,如果我们以其他数据类型作为键，它会自动转化为String，而ES6新增加的Map数据结构解决了这个问题，Map跟对象一样是键值对的集合，但是它的键可以是任意一种数据类型，如：</p><pre><code><strong><span style=\"color:#333333\">let</span></strong> m = <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">Map</span>([  <br/>  [<span style=\"color:#dd1144\">&#x27;string&#x27;</span>, <span style=\"color:#008080\">1</span>],  <br/>  [<span style=\"color:#008080\">1</span>, <span style=\"color:#dd1144\">&#x27;string&#x27;</span>],<br/>  [<span style=\"color:#008080\">true</span>, <span style=\"color:#008080\">false</span>],<br/>  [{name: <span style=\"color:#dd1144\">&#x27;zhang&#x27;</span>}, <span style=\"color:#dd1144\">&#x27;20&#x27;</span>],<br/>  [<strong><span style=\"color:#333333\">function</span></strong> () {}, <span style=\"color:#008080\">100</span>]<br/>]);<br/><br/><strong><span style=\"color:#333333\">for</span></strong> (<strong><span style=\"color:#333333\">let</span></strong> i <strong><span style=\"color:#333333\">of</span></strong> m.keys()) {<br/>  <span style=\"color:#0086b3\">console</span>.log(<strong><span style=\"color:#333333\">typeof</span></strong> i);<br/>}<br/><em><span style=\"color:#999988\">// string, number, boolean, object, function</span></em></code></pre><p></p><h2 style=\"text-align:start;\">Map中的属性和方法</h2><p style=\"text-align:start;text-indent:2em;\"></p><p>1.size属性：Map实例中成员的个数<br/>2.set(key, value)     // 为键赋一个值，若有这个键则覆盖原值，没有新建，返回整个Map结构<br/>3.get(value)    //获取某一个键的值，找不到返回undefined<br/>4.has(key)    //判断某个键是否存在Map对象中<br/>5.delete(key)    //删除某个键<br/>6.clear()    //清空Map对象</p><p style=\"text-align:start;text-indent:2em;\"></p><p>遍历方法同上面的Set，不过这里要提醒一下，Set里默认的遍历器接口是values方法，而Map默认遍历器接口是entries方法，即</p><pre><code><span style=\"color:#0086b3\">Set</span>.prototype[<span style=\"color:#0086b3\">Symbol</span>.iterator] === <span style=\"color:#0086b3\">Set</span>.values <em><span style=\"color:#999988\">//true  </span></em><br/><span style=\"color:#0086b3\">Map</span>.prototype[<span style=\"color:#0086b3\">Symbol</span>.iterator] === <span style=\"color:#0086b3\">Map</span>.entries <em><span style=\"color:#999988\">// true</span></em></code></pre><p></p><p></p><h1 style=\"text-align:start;\">WeakMap</h1><p style=\"text-align:start;text-indent:2em;\"></p><p>和Map结构相似，只是它的键只能是对象，而且对对象的引用同样是弱引用；<br/>WeakMap没有size属性，不能进行遍历，只有四个方法get()、set()、has()、delete()，操作同上面的Map。</p><p></p><h2 style=\"text-align:start;\">应用</h2><p style=\"text-align:start;text-indent:2em;\"></p><p>WeakMap的应用有两方面，一方面我们用来对一个对象进行弱引用，比如我们要给获取到的一个DOM节点对象加上一个数据，我们可以这么做：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> el1 = <span style=\"color:#0086b3\">document</span>.getElementById(<span style=\"color:#dd1144\">&#x27;div1&#x27;</span>);<br/><strong><span style=\"color:#333333\">const</span></strong> el2 = <span style=\"color:#0086b3\">document</span>.getElementById(<span style=\"color:#dd1144\">&#x27;div2&#x27;</span>);<br/><br/><strong><span style=\"color:#333333\">const</span></strong> arr = [<br/>  [el1, <span style=\"color:#dd1144\">&#x27;我是div1&#x27;</span>],<br/>  [el2, <span style=\"color:#dd1144\">&#x27;我是div2&#x27;</span>]<br/>]</code></pre><p style=\"text-align:start;\">这样arr就有对el1,el2对象的一个引用，当不再需要这两个对象时我们要手动清除arr对这两个对象的引用：</p><pre><code>arr[0] = null;<br/>arr[1] = null;</code></pre><p style=\"text-align:start;\">若采用weakMap来引用：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> el1 = <span style=\"color:#0086b3\">document</span>.getElementById(<span style=\"color:#dd1144\">&#x27;div1&#x27;</span>);<br/><strong><span style=\"color:#333333\">const</span></strong> el2 = <span style=\"color:#0086b3\">document</span>.getElementById(<span style=\"color:#dd1144\">&#x27;div2&#x27;</span>);<br/><br/><strong><span style=\"color:#333333\">const</span></strong> wk = <strong><span style=\"color:#333333\">new</span></strong> WeakMap();<br/>wk.<strong><span style=\"color:#333333\">set</span></strong>(el1, <span style=\"color:#dd1144\">&#x27;我是div1&#x27;</span>);<br/>wk.<strong><span style=\"color:#333333\">set</span></strong>(el2, <span style=\"color:#dd1144\">&#x27;我是div2&#x27;</span>);<br/>wk.<strong><span style=\"color:#333333\">get</span></strong>(el1); <em><span style=\"color:#999988\">//   “我是div1”</span></em></code></pre><p style=\"text-align:start;\">当我们不再需要这，两个对象时就不必手动取消对它们的引用了；<br/>另一方面我们可以利用weakMap来设置私有变量，以前我们这样来设置私有变量：</p><pre><code><strong><span style=\"color:#333333\">class</span></strong> <strong><span style=\"color:#445588\">Student</span></strong> {<br/>  <strong><span style=\"color:#333333\">constructor</span></strong> (name) {<br/>    <strong><span style=\"color:#333333\">this</span></strong>._name = name;<br/>  }<br/>  getName () {<br/>    <strong><span style=\"color:#333333\">return</span></strong> <strong><span style=\"color:#333333\">this</span></strong>._name;<br/>  }<br/>}</code></pre><p style=\"text-align:start;\">我们一般采用在变量前面加_来定义私有变量，但是这个私有变量对外还是可访问的：</p><pre><code><strong><span style=\"color:#333333\">let</span></strong> student<span style=\"color:#008080\">1</span> = <strong><span style=\"color:#333333\">new</span></strong> Student(<span style=\"color:#dd1144\">&#x27;xiaoming&#x27;</span>);<br/>student<span style=\"color:#008080\">1._n</span>ame; <em><span style=\"color:#999988\">// &quot;xiaoming&quot;</span></em></code></pre><p style=\"text-align:start;\">来看下我们用weakMap定义私有变量：</p><pre><code>let _name = new WeakMap();<br/><strong><span style=\"color:#333333\">class</span></strong> <strong><span style=\"color:#445588\">Student</span></strong> {<br/>  <strong><span style=\"color:#333333\">constructor</span></strong> (name) {<br/>    _name.<strong><span style=\"color:#333333\">set</span></strong>(<strong><span style=\"color:#333333\">this</span></strong>, name);<br/>  }<br/>  getName () {<br/>    <strong><span style=\"color:#333333\">return</span></strong> _name.<strong><span style=\"color:#333333\">get</span></strong>(<strong><span style=\"color:#333333\">this</span></strong>);<br/>  }<br/>}</code></pre><p style=\"text-align:start;\">这样我们取得对象的name属性只能通过getName()方法；<br/>使用WeakMap存储数据不会产生属性名，可以用*Reflect.ownKeys()*来验证；</p><p></p><p></p><h1 style=\"text-align:start;\">Proxy</h1><p style=\"text-align:start;text-indent:2em;\"></p><p>Proxy翻译成代理，可以当作理器；</p><blockquote style=\"text-align:start;text-indent:2em;\">Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</blockquote><p style=\"text-align:start;\">Proxy就是在目标对象上架设了一层“拦截”，当对该对象进行访问时都必须通过这层“拦截”，通常是对外界的访问进行过滤和改写。</p><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>1.使用方法</h2><pre><code>const<span style=\"color:#0086b3\"> proxy </span>= new Proxy(target, handler)；</code></pre><p style=\"text-align:start;\">target是目标对象，handler也是一个对象，定义了一系列的拦截行为，如：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> handler = {  <br/>  <span style=\"color:#000080\">get</span>: <strong><span style=\"color:#333333\">function</span></strong> (target, name) {<br/>    <strong><span style=\"color:#333333\">if</span></strong> (<strong><span style=\"color:#333333\">if</span></strong> name === <span style=\"color:#dd1144\">&#x27;prototype&#x27;</span>) {<br/>      <strong><span style=\"color:#333333\">return</span></strong> <span style=\"color:#0086b3\">Object</span>.prototype;<br/>    }<br/>    <strong><span style=\"color:#333333\">return</span></strong> <span style=\"color:#dd1144\">&#x60;hello <span style=\"color:#333333\">${name}</span>&#x60;</span>;       <br/>  }<br/>  <span style=\"color:#000080\">constructor</span>: <strong><span style=\"color:#333333\">function</span></strong> (target, args) {<br/>    <strong><span style=\"color:#333333\">return</span></strong> args[<span style=\"color:#008080\">1</span>];<br/>  }<br/>};<br/><br/><strong><span style=\"color:#333333\">const</span></strong> proxy = <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">Proxy</span>(<strong><span style=\"color:#333333\">function</span></strong> (x, y) {<br/>  <strong><span style=\"color:#333333\">return</span></strong> x + y;<br/>}, handler);  <br/><br/><strong><span style=\"color:#333333\">new</span></strong> proxy(<span style=\"color:#008080\">1</span>, <span style=\"color:#008080\">2</span>); <em><span style=\"color:#999988\">// 2</span></em><br/>proxy.prototype === <span style=\"color:#0086b3\">Object</span>.prototype; <em><span style=\"color:#999988\">// true</span></em><br/>proxy.lin; <em><span style=\"color:#999988\">// &quot;hello lin&quot;</span></em></code></pre><p style=\"text-align:start;\">如上，对一个函数对象的get操作和new操作设置了拦截，使用new操作符实际上就是调用了对象的<em>constructor</em>方法，因此输出了第二个参数的值。</p><p></p><h2 style=\"text-align:start;\">2. Proxy拦截方法</h2><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>1. get()</h3><p style=\"text-align:start;text-indent:2em;\"></p><p>该方法接收三个参数，目标对象、属性名和Proxy实例的对象，第三个参数可省略:</p><pre><code><strong><span style=\"color:#333333\">var</span></strong> person = {<br/>  <span style=\"color:#000080\">name</span>: <span style=\"color:#dd1144\">&quot;xiaoming&quot;</span><br/>};<br/><br/><strong><span style=\"color:#333333\">const</span></strong> proxy = <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">Proxy</span>(person, {<br/>  <span style=\"color:#000080\">get</span>: <strong><span style=\"color:#333333\">function</span></strong> (target, property) {<br/>    <strong><span style=\"color:#333333\">if</span></strong> (<strong><span style=\"color:#333333\">property</span></strong><span style=\"color:#dd1144\"> in target) {</span><br/>      <strong><span style=\"color:#333333\">return</span></strong> target[peoperty];<br/>    } <strong><span style=\"color:#990000\">else</span></strong> {<br/>      <strong><span style=\"color:#333333\">return</span></strong> <strong><span style=\"color:#333333\">throw</span></strong> <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">ReferenceError</span>(<span style=\"color:#dd1144\">&quot;Property \\&#x27;&quot;</span> + <strong><span style=\"color:#333333\">property</span></strong><span style=\"color:#dd1144\"> + &quot;\\&#x27; does not exist.&quot;)</span>;<br/>    }<br/>  }<br/>});<br/><br/>proxy.name; <em><span style=\"color:#999988\">// &quot;xiaoming&quot;</span></em><br/>proxy.age; <em><span style=\"color:#999988\">// &quot;Property&#x27;age&#x27;does not exist.&quot;</span></em></code></pre><p style=\"text-align:start;\">这个例子表示访问的属性存在则正常输出不存在就跑出一个错误；</p><p>get()方法可以继承，如在上面那个例子中添加：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> person = {<br/>  <span style=\"color:#000080\">name</span>: <span style=\"color:#dd1144\">&quot;xiaoming&quot;</span><br/>};<br/><br/><strong><span style=\"color:#333333\">const</span></strong> proxy = <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">Proxy</span>(person, {<br/>  <span style=\"color:#000080\">get</span>: <strong><span style=\"color:#333333\">function</span></strong> (target, property) {<br/>    <strong><span style=\"color:#333333\">if</span></strong> (<strong><span style=\"color:#333333\">property</span></strong><span style=\"color:#dd1144\"> in target) {</span><br/>      <strong><span style=\"color:#333333\">return</span></strong> target[peoperty];<br/>    } <strong><span style=\"color:#990000\">else</span></strong> {<br/>      <strong><span style=\"color:#333333\">return</span></strong> <strong><span style=\"color:#333333\">throw</span></strong> <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">ReferenceError</span>(<span style=\"color:#dd1144\">&quot;Property \\&#x27;&quot;</span> + <strong><span style=\"color:#333333\">property</span></strong><span style=\"color:#dd1144\"> + &quot;\\&#x27; does not exist.&quot;)</span>;<br/>    }<br/>  }<br/>});<br/><br/><strong><span style=\"color:#333333\">const</span></strong> newPerson = <span style=\"color:#0086b3\">Object</span>.create(proxy);<br/><br/>newPerson.name; <em><span style=\"color:#999988\">// &quot;xiaoming&quot;</span></em><br/>newPerson.age; <em><span style=\"color:#999988\">// &quot;Property&#x27;age&#x27;does not exist.&quot;</span></em></code></pre><p style=\"text-align:start;\">newPerson继承了proxy对象中读取属性的方法；</p><p></p><h3 style=\"text-align:start;\">2. set()</h3><p style=\"text-align:start;text-indent:2em;\"></p><p>set()用来拦截某个属性的赋值操作，接收四个参数，目标对象和，属性，属性值，proxy实例，若该对象的某个属性[[configurable]]和[[writable]]设置为false，则不能用set方法进行修改，否则会报错；</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> proxy = <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">Proxy</span>({}, {<br/>  <span style=\"color:#000080\">set</span>: <strong><span style=\"color:#333333\">function</span></strong> (target, property, value, receiver) {<br/>    target[<strong><span style=\"color:#333333\">property</span></strong><span style=\"color:#dd1144\">] </span>= value;<br/>    <span style=\"color:#0086b3\">console</span>.log(receiver);<br/>  }<br/>});<br/><br/>proxy.age = <span style=\"color:#008080\">22</span>; <em><span style=\"color:#999988\">// proxy</span></em></code></pre><p style=\"text-align:start;\">上面的例子给一个空对象的赋值操作设置了set的拦截，当为一个属性设值时会打印出proxy的实例对象；</p><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>3.apply()</h3><p style=\"text-align:start;\">apply()拦截函数的调用、apply()和call()方法，它接收三个参数，分别是目标函、所在上下文和传入的参数，设置方法如下：</p><pre><code><strong><span style=\"color:#333333\">const</span></strong> proxy = <strong><span style=\"color:#333333\">new</span></strong> <span style=\"color:#0086b3\">Proxy</span>(<strong><span style=\"color:#333333\">function</span></strong> (x, y) {<br/>  <strong><span style=\"color:#333333\">return</span></strong> x + y;<br/>}, {<br/>  apply (target, ctx, args) {<br/>    <strong><span style=\"color:#333333\">return</span></strong> args[<span style=\"color:#008080\">0</span>];<br/>  }<br/>});  <br/><br/>proxy(<span style=\"color:#008080\">2</span>, <span style=\"color:#008080\">4</span>);  <em><span style=\"color:#999988\">// 2</span></em></code></pre><p style=\"text-align:start;\">上面在apply上设置了一层拦截，当调用这个函数时就返回参数的第一个；</p><p></p><h3 style=\"text-align:start;\">4.has()</h3><p>这个方法用来拦截HasProperty操作，即检查一个对象中是否有该属性，它只检查属性是否存在而不检查属性是自己的还是继承的；<br/>has()拦截对<em>in</em>生效但对<em>for...in</em>不生效。</p><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>5.constructor()</h3><p>这个方法用来拦截对象的new操作，接收两个参数，目标对象和构造函数的参数对象，切constructor必须返回一个对象，否则会报错。</p><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>6.deleteProperty()</h3><p style=\"text-align:start;\">拦截delete操作，如果对象的某个属性*[[configurable]]*设置为false，则使用该方法删除属性会报错。</p><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>7.setPrototypeOf() &amp; getPrototypeOf()</h3><p style=\"text-align:start;\">用来拦截设置某对象的对象原型和获取某对象的原型，若目标对象不可扩展(extensible)，则两个方法都不得使用；getPrototypeOf()方法必须返回对象的原型对象，setPrototypeOf()方法返回一个布尔值。</p><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>8.ownKeys()</h3><p style=\"text-align:start;\">该方法用来拦截对象自身属性的读取操作，具体拦截一下方法：</p><ul><li>Object.getOwnPropertyNames()</li><li>Object.getOwnPropertySymbols()</li><li>Object.keys()</li></ul><p style=\"text-align:start;\">ownKeys()方法只能返回数组切数组成员必须是字符串或者Symbol值。</p><p></p><h2 style=\"text-align:start;\">3. Proxy.revocable()</h2><p style=\"text-align:start;text-indent:2em;\"></p><p>该方法返回一个可取消的proxy实例，如：</p><pre><code>let <strong><span style=\"color:#333333\">target</span></strong> = {};<br/>let <strong><span style=\"color:#333333\">handler</span></strong> = {};<br/><br/>let {proxy, revoke} = Proxy.revocable(<strong><span style=\"color:#333333\">target</span></strong>, <strong><span style=\"color:#333333\">handler</span></strong>);<br/><br/>proxy.foo = <span style=\"color:#008080\">123</span>;<br/>proxy.foo <em><span style=\"color:#999988\">// 123</span></em><br/><br/>revoke();<br/>proxy.foo <em><span style=\"color:#999988\">// TypeError: Revoked</span></em></code></pre><p style=\"text-align:start;\">返回的实例里proxy属性是proxy实例，revoke是一个函数，用于取消proxy实例；</p><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>4.关于this的问题</h2><p style=\"text-align:start;\">用Proxy代理目标对象时，目标对象中的<em>this</em>值指向的是proxy实例而不是目标函数。</p><p></p><h1 style=\"text-align:start;text-indent:2em;\"></h1><h1>Reflect</h1><p style=\"text-align:start;\">引入Reflect对象主要是将Object对象中一些语言内部的方法放到Reflect对象上，可以通过Reflect对象来调用这些方法；还可有修改Object方法的返回结果，比如，*Object.defineProperty(obj, name, desc)<em>在无法定义属性时，会抛出一个错误，而</em>Reflect.defineProperty(obj, name, desc)*则会返回false。</p><p style=\"text-align:start;\">Reflect对象上的方法和Proxy对象伤的方法意义对应，不管Proxy怎么对默认方法拦截，都可以直接通过Reflect对象来访问默认方法；</p><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>Reflect对象的静态方法</h2><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>1. Reflect.get(target, name, receiver)</h3><p style=\"text-align:start;text-indent:2em;\">target目标对象，name属性，如果目标对象属性设置了getter函数，则读取函数上的<em>this</em>指向receiver；<br/>若第一个参数不是对象会报错。</p><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>2. Reflect.set(target, name, value, receiver)</h3><p style=\"text-align:start;text-indent:2em;\">若目标对象的属性设置了setter函数，则该函数上的<em>this</em>对象指向receiver。<br/>注意，若Reflect.set()与Proxy一起使用，Proxy在set方法上设置了拦截，若Reflect.set()传入了receiver参数会触发<em>defineProperty</em>拦截，不传则不会拦截。</p><h3 style=\"text-align:start;text-indent:2em;\"></h3><h3>3. Reflect.has(obj, name) &amp; Reflect.deleteProperty(obj, name)</h3><p style=\"text-align:start;text-indent:2em;\"><em>Reflect.has(obj, name)</em> 相当于 name in obj, *Reflect.deleteProperty(obj, name)*相当于 delete obj[name]</p><p></p><h3 style=\"text-align:start;\">4. Reflect.construct(target, args)</h3><p style=\"text-align:start;text-indent:2em;\">相当于 new target(...args),因此我们调用构造函数的方法就可以为：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">Person</span></strong> (name) {<br/>  <strong><span style=\"color:#333333\">this</span></strong>.name = name<br/>};<br/><strong><span style=\"color:#333333\">var</span></strong> person = <strong><span style=\"color:#333333\">new</span></strong> Person(<span style=\"color:#dd1144\">&#x27;xiaoming&#x27;</span>);<br/><br/><em><span style=\"color:#999988\">// 等价于</span></em><br/><br/><strong><span style=\"color:#333333\">var</span></strong> person = <span style=\"color:#0086b3\">Reflect</span>.construct(Person, [<span style=\"color:#dd1144\">&#x27;xiaoming&#x27;</span>]);</code></pre><h3 style=\"text-align:start;\">5. Reflect.getPrototypeOf(obj) &amp; Reflect.setPrototypeOf(obj, newproto)</h3><p style=\"text-align:start;text-indent:2em;\"><em>Reflect.getPrototypeOf(obj)读取函数的proto属性，对应Object.getPrototypeOf()</em>,如果传入的不是对象，*Reflect.getPrototypeOf(obj)*会报错，*Object.getPrototypeOf()*会转换为对象；</p><p style=\"text-align:start;text-indent:2em;\"><em>Reflect.setPrototypeOf(obj, newproto)改变对象的proto</em>，对应<em>Object.setPrototypeOf()</em>,如果传入的参数不是对象，<em>Reflect.setPrototypeOf()报错，Object.setPrototypeOf()会返回参数，若传入null或undefined</em>两个都会报错。</p><p></p><p></p>', 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3002156381,3399141955&fm=26&gp=0.jpg', '12', '本文是es6的进阶知识，包括Map,WeakMap,Set,WeakSet四种新的数据结构以及新引进的原生对象Proxy,该对象用来代理对象的一些原生方法,Reflect对象用来放Object对象上的内部方法。', '[\"ES6\",\"知识进阶\"]', '2019-05-28 18:10:27', '1', '7', '0'), ('44', '闭包', '17', '2019-05-28 18:17:50', '178', '1', '<p style=\"text-indent:2em;\"><span style=\"color:#24292e\"><span style=\"font-size:14px\">闭包是js中一个重要的概念，初学者学js难点就是在于</span></span><em>原型链</em><span style=\"color:#24292e\"><span style=\"font-size:14px\">和</span></span><em>闭包</em><span style=\"color:#24292e\"><span style=\"font-size:14px\">这两个问题上，上一篇</span></span><a href=\"http://www.lsshuai.com/article/13\" target=\"_blank\">《详解JavaScript面向对象编程(二)》</a><span style=\"color:#24292e\"><span style=\"font-size:14px\">讲到了什么是原型链，这篇文章将js另一个难点深入理解一下。</span></span></p><p></p><h1 style=\"text-align:start;\">执行上下文环境&amp;上下文栈</h1><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>执行上下文</h2><p></p><p style=\"text-align:start;text-indent:2em;\">什么是<em>执行上下文环境</em>？我们先来看一段代码：</p><pre><code><span style=\"color:#0086b3\">console</span>.log(a);  <em><span style=\"color:#999988\">// undefined</span></em><br/><span style=\"color:#0086b3\">console</span>.log(<strong><span style=\"color:#333333\">this</span></strong>)； <em><span style=\"color:#999988\">//window</span></em><br/>b(); <em><span style=\"color:#999988\">// b() is not a function </span></em><br/>c(); <em><span style=\"color:#999988\">// &quot;c&quot;</span></em><br/><strong><span style=\"color:#333333\">var</span></strong> a = <span style=\"color:#dd1144\">&quot;a&quot;</span>;<br/><strong><span style=\"color:#333333\">var</span></strong> b = <strong><span style=\"color:#333333\">function</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> b = <span style=\"color:#dd1144\">&quot;b&quot;</span><br/>  <span style=\"color:#0086b3\">console</span>.log(b);<br/>}  <br/><br/><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">c</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> c = <span style=\"color:#dd1144\">&quot;c&quot;</span><br/>  <span style=\"color:#0086b3\">console</span>.log(c);<br/>}</code></pre><p style=\"text-align:start;text-indent:2em;\">我们知道用<em>var</em>声明的变量存在变量提升，函数表达式和函数声明定义的函数也存在变量提升，但是前者跟变量提升一样，不会把整个函数体一起提升，后者会将函数体一起提升；<br/>“提升”发生在一段代码执行之前，是一段代码执行之前的准备工作，一段代码执行需要准备如下工作：</p><ul><li>变量、函数表达式声明并赋值，默认值为undefined</li><li>给<strong>this</strong>赋值</li><li>函数声明的函数赋值</li></ul><p style=\"text-align:start;\">我们把执行一段代码之前的准备情况称之为<em>执行上下文</em>或者<em>执行上下文环境</em></p><p></p><h2 style=\"text-align:start;\">上下文栈</h2><p></p><p style=\"text-align:start;text-indent:2em;\"><em>上下文栈</em>就是一个存储<em>执行上下文</em>的栈，栈中只有一个上下文是处于活动状态的，执行全局代码时就会有一个全局上下文被压入栈，调用一个函数时就会产生一个函数的上下文环境，然后将其压入栈，目前它处于活动状态，当函数执行完后其执行上下文环境出栈，它的上下文环境和里面的数据被销毁，内存被回收，如下图是上例中代码执行时上下文栈的变化：</p><p></p><p></p><h1 style=\"text-align:start;\">作用域&amp;作用域链</h1><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>js的作用域 - 词法作用域</h2><p></p><p style=\"text-align:start;text-indent:2em;\">js的作用域是<em>词法作用域(静态作用域)</em>，实际上大部分的语言作用域都是<em>词法作用域</em>，与词法作用域相对的是<em>动态作用域</em>，我们来看下面的例子：</p><pre><code><strong><span style=\"color:#333333\">var</span></strong> a = <span style=\"color:#008080\">10</span>;<br/><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">logA</span></strong> () {<br/>  <span style=\"color:#0086b3\">console</span>.log(a);<br/>}  <br/><br/><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">b</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> a = <span style=\"color:#008080\">20</span>;<br/>  logA();<br/>}<br/><br/>b();</code></pre><p style=\"text-align:start;text-indent:2em;\">上面代码的结果是什么？可以在打印台打印出来看一下，结果是10，为什么不是20呢？我们前面讲过，js的作用域是<em>词法作用域</em>，<em>词法作用域</em>关注的是函数在哪里声明的，而<em>动态作用域</em>关注的是函数在哪里调用的，上面logA是在全局作用域中声明的，它内部要访问变量a，先在自己作用域中找，若找不到便向声明它的作用域中找，其实寻找变量a就是按照<em>作用域链</em>来找的，所以上面最后输出的是10而不是20；</p><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>作用域链</h2><p></p><p style=\"text-align:start;text-indent:2em;\">上面讲的寻找a的这个“跨”作用域的路线就是我们说的作用域链，在一个函数被创建时它的内部属性*[[scope]]<em>会保存一个预先包含全局作用域中变量的作用域链，当调用该函数时会创建一个该函数的执行上下文，然后赋值函数内</em>[[scope]]*的对象构建函数执行环境的作用域链，再把执行环境中的变量对象放到作用域链前端；<br/>作用域链本质上是一个指向变量对象的指针。</p><p></p><h1 style=\"text-align:start;text-indent:2em;\"></h1><h1>闭包</h1><p></p><p style=\"text-align:start;\">什么是闭包？《js高级程序设计》是这样定义的：</p><blockquote style=\"text-align:start;\">闭包是指有权访问另一个函数作用域中变量的函数。<br/>我们来看一下下面这段代码：</blockquote><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">a</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> x = <span style=\"color:#008080\">12</span>;<br/>  <strong><span style=\"color:#333333\">return</span></strong> <strong><span style=\"color:#333333\">function</span></strong> () {<br/>    <strong><span style=\"color:#333333\">var</span></strong> y = <span style=\"color:#008080\">10</span>;<br/>    <strong><span style=\"color:#333333\">return</span></strong> x + y;<br/>  }<br/>}<br/><br/><strong><span style=\"color:#333333\">var</span></strong> b = a();<br/>b(); <em><span style=\"color:#999988\">// 22</span></em></code></pre><p style=\"text-align:start;text-indent:2em;\">上面代码中，在全局执行上下文中定义了一个函数a和一个变量b，函数a的执行上下文中声明了一个变量x且赋值12，内部还返回一个匿名函数，所以此刻匿名函数的作用域链初始化为包含了全局变量对象和a中的变量对象，当执行<em>var b = a();时就是把a函数内的匿名函数赋值给b，即函数当值传递</em>；这段代码一开始上下文栈只有全局执行上下文，当运行到*var b = a();<em>时，把函数a的执行上下文压入栈，这一句代码执行完后按理a的执行上下文应该出栈，但是因为a内部的匿名函数的作用域链还引用着a的变量x,所以a的执行上下文得不到释放，这就形成了闭包，当执行到</em>b();*时把a中的匿名函数的执行上下文压入上下文栈，此时栈中有三个执行上下文。</p><p></p><p></p><h1 style=\"text-align:start;\">闭包的使用</h1><h2 style=\"text-align:start;text-indent:2em;\"></h2><h2>作用域链指向的变量对象</h2><p></p><p style=\"text-align:start;text-indent:2em;\">上文讲过<em>作用域链</em>就是指向变量对象的指针，所闭包只能取得包含函数中任何变量的最后一个值，如下代码：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">a</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> arr = [];<br/>  <br/>  <strong><span style=\"color:#333333\">for</span></strong> (<strong><span style=\"color:#333333\">var</span></strong> i = <span style=\"color:#008080\">0</span>; i &lt; <span style=\"color:#008080\">12</span>; i++) {<br/>    arr[i] = <strong><span style=\"color:#333333\">function</span></strong> () {<br/>      <strong><span style=\"color:#333333\">return</span></strong> i;<br/>    } <br/>  }<br/>  <br/>  <strong><span style=\"color:#333333\">return</span></strong> arr;  <em><span style=\"color:#999988\">// [11,11,...,11]</span></em><br/>}</code></pre><p style=\"text-align:start;text-indent:2em;\">这段代码作用是返回一个数组[0,1,2,...,11],但是机上返回的是一个包含12个11的数组，因为里面的每个匿名函数的作用域链上的变量对象i是指向的同一个变量i，所以它们的值都相等，我们可以这样修改：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">a</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> arr = [];<br/>  <br/>  <strong><span style=\"color:#333333\">for</span></strong> (<strong><span style=\"color:#333333\">var</span></strong> i = <span style=\"color:#008080\">0</span>; i &lt; <span style=\"color:#008080\">12</span>; i++) {<br/>    arr[i] = <strong><span style=\"color:#333333\">function</span></strong> (num) {<br/>      <strong><span style=\"color:#333333\">return</span></strong> num;<br/>    }(i); <br/>  }<br/>  <br/>  <strong><span style=\"color:#333333\">return</span></strong> arr;<br/>}</code></pre><p style=\"text-align:start;\">这种方法的意思是把当前i的值传递给匿名函数的参数num，然后立即执行*(IIFE)*返回给数组的相应项；</p><p></p><h2 style=\"text-align:start;\">模块模式</h2><p></p><p style=\"text-align:start;\">这里我们先看以下代码：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">hello</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> textE = <span style=\"color:#dd1144\">&#x27;hello!&#x27;</span>;<br/>  <strong><span style=\"color:#333333\">var</span></strong> textC = <span style=\"color:#dd1144\">&#x27;你好!&#x27;</span>;<br/><br/>  helloInChinese () {<br/>    <span style=\"color:#0086b3\">console</span>.log(textC);<br/>  };<br/><br/>  helloInEnglish () {<br/>    <span style=\"color:#0086b3\">console</span>.log(textE);<br/>  };<br/>}</code></pre><p style=\"text-align:start;\">这里没有明显的闭包，只是hello函数里又声明了两个函数，我们可以这样做：</p><pre><code><strong><span style=\"color:#333333\">function</span></strong> <strong><span style=\"color:#990000\">hello</span></strong> () {<br/>  <strong><span style=\"color:#333333\">var</span></strong> textE = <span style=\"color:#dd1144\">&#x27;hello!&#x27;</span>;<br/>  <strong><span style=\"color:#333333\">var</span></strong> textC = <span style=\"color:#dd1144\">&#x27;你好!&#x27;</span>;<br/><br/>  helloInChinese () {<br/>    <span style=\"color:#0086b3\">console</span>.log(textC);<br/>  };<br/><br/>  helloInEnglish () {<br/>    <span style=\"color:#0086b3\">console</span>.log(textE);<br/>  };<br/><br/>  <strong><span style=\"color:#333333\">return</span></strong> {<br/>    helloInChinese: helloInChinese,<br/>    helloInEnglish: helloInEnglish<br/>  }<br/>}</code></pre><p style=\"text-align:start;\">现在这个函数执行后将返回一个对象，对象包含的是hello内部的两个私有函数，这是我们调用hello后就会形成闭包，如下：</p><pre><code>var sayHi = hello();<br/>sayHi.helloInChinese(); <span style=\"color:#009926\">//</span> <span style=\"color:#dd1144\">&quot;你好!&quot;</span><br/>sayHi.helloInEnglish(); <span style=\"color:#009926\">//</span> <span style=\"color:#dd1144\">&quot;hello!&quot;</span></code></pre><p style=\"text-align:start;\">因为这时hello函数返回了一个对象，而sayHi引用着这个对象，而对象里面是两个方法，这两个方法又引用着hello里的两个变量，所以hello的执行上下文不会出栈，若要释放，就必须手动接触sayHi对这个对象的引用，即<em>sayHi = null</em>；</p><p style=\"text-align:start;\">这种做法就称之为“模块”，即把内部的方法向外部暴露出来，让外部作用域能访问内部的变量；</p><p></p><p></p><h1 style=\"text-align:start;\">总结</h1><p></p><p style=\"text-align:start;\">1.什么是<em>执行上下文</em>和<em>上下文栈</em>？<br/><em>执行上下文</em>是执行一段代码之前的准备工作，准备工作包括以下三点：</p><ul><li>变量、函数表达式声明并赋值，默认值为undefined</li><li>给<strong>this</strong>赋值</li><li>函数声明的函数赋值</li></ul><p style=\"text-align:start;text-indent:2em;\"><em>上下文栈</em>即用来保存执行上下文，当某一段代码执行时就把它的执行上下文入栈，执行完后就出栈并销毁，释放内存，一个上下文栈只有一个执行上下文处于活动状态；</p><p></p><p style=\"text-align:start;\">2.什么是<em>作用域</em>和<em>作用域链</em></p><p style=\"text-align:start;text-indent:2em;\"><em>作用域</em>简单说就是作用的范围，初始化时就存在<em>全局作用域</em>，当函数声明时函数就自己创建了一个自己的<em>作用域</em>，当要访问某个变量时函数先在自己的<em>作用域</em>中找，找不到就向声明它的<em>作用域</em>中找，找不到就一直找直到全局作用域；<br/><em>作用域链</em>：作用域链也是在函数声明时创建的，一开始包含声明它的作用域及以上的变量对象，保存在函数内部的*[[scope]]<em>属性中，当调用该函数时就赋值</em>[[scope]]*中的作用域链给它的执行上下文并往作用域链前端加上它执行上下文中声明的变量对象；<br/></p><p>3.闭包的形成及优缺点：</p><p style=\"text-align:start;text-indent:2em;\">形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收；</p><p><br/><strong>优点：</strong></p><ul><li>闭包里的变量不会污染全局，因为变量被封在闭包里；</li><li>所有变量都在闭包里保证了隐私性和私有性；</li></ul><p style=\"text-align:start;\"><strong>缺点：</strong></p><ul><li>闭包被引用后不能自动被释放，会造成内存泄漏，若不再用到需要手动解除引用；</li></ul><p style=\"text-align:start;\"><em><span style=\"background-color:#cccccc\">(完)</span></em></p>', 'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3944526102,2008044000&fm=26&gp=0.jpg', '12', '文章深入理解了什么是闭包，闭包的作用，从上下文环境和上下文栈开始，然后讲什么是作用域和作用域链，闭包的形成及闭包的优缺点；', '[\"闭包\",\"js基础\"]', '2019-05-28 18:17:46', '1', '2', '0'), ('45', 'js任务队列机制——事件循环', '17', '2019-09-27 18:28:18', '7', '0', '<p style=\"text-indent:2em;\"><span style=\"color:#24292e\"><span style=\"font-size:14px\">我们都知道js的执行环境是</span></span><em>单线程</em><span style=\"color:#24292e\"><span style=\"font-size:14px\">，所谓</span></span><em>单线程</em><span style=\"color:#24292e\"><span style=\"font-size:14px\">就是一次只能执行一个任务，后面的任务需要等待前面的任务执行完后才会执行，</span></span><em>单线程</em><span style=\"color:#24292e\"><span style=\"font-size:14px\">的执行环境简单，但是如果一段代码执行的时间过长就会卡在那里，这就造成了浏览器“假死”；</span></span></p><p></p><h1 style=\"text-align:start;\">同步 &amp; 异步</h1><p></p><p style=\"text-align:start;\"><strong>js中任务执行有两种模式：</strong></p><p><br/><em>同步模式</em>：即后一个任务需要等待前一个任务执行完后才执行，执行的顺序就是任务的排列顺序；<br/><em>异步模式</em>：异步模式一个任务执行完后不是执行下一个任务，而是执行它的回调函数，下一个任务也不必等它前一个任务执行完就执行，异步执行任务是不安顺序的，异步的；</p><p><br/><em><span style=\"background-color:#fdda00\">初学者经常有这个疑问，既然js是“单线程”的又怎么实现异步呢？</span></em></p><p><br/>js是单线程其实是指浏览器只有一个执行线程用来执行js代码，而浏览器还有其他常驻线程，比如我们发送一个http请求就是由js执行线程和事件触发进程来执行的，js执行进程触发一个http请求，事件触发线程就发送http请求，而js执行线程不用等请求回复继续执行下面的任务，当http请求返回时再通知主线程在某一时刻处理请求的返回；</p><p></p><h1 style=\"text-align:start;text-indent:2em;\"></h1><h1>异步任务队列</h1><p></p><p style=\"text-align:start;\">我们来看这样一段代码：</p><pre><code>setTimeout(() =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;a&#x27;</span>);<br/>}, <span style=\"color:#008080\">0</span>);<br/><br/><span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;b&#x27;</span>);<br/><br/>setTimeout(() =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;c&#x27;</span>);<br/>}, <span style=\"color:#008080\">0</span>);</code></pre><p style=\"text-align:start;\">这段代码的输出结果为“b a c”,因为第一个时间函数比第二个先注册，由此我们可以得出结论：</p><p><br/>异步事件是在同步事件之后执行的，即同步事件和异步事件由不同的任务队列管理，js主线程先执行同步队列中的任务，待主线程空闲时就从异步队列中顺序取出任务来执行；</p><p><br/>但是真的是这样吗？<br/>因为时间器是有最小时间间隔的，在这个时间间隔里同步代码完全可以执行完：</p><blockquote style=\"text-align:start;\">定时器最小时间间隔：在苹果机上的最小时间间隔是10ms，在Windows系统上的最小时间间隔大约是15ms。Firefox中定义的最小时间间隔是10ms，而HTML5规范中定义的最小时间间隔是4ms。</blockquote><p></p><p style=\"text-align:start;\">我们可以修改上面的代码：</p><pre><code>setTimeout(() =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;a&#x27;</span>);<br/>}, <span style=\"color:#008080\">0</span>);<br/><br/><strong><span style=\"color:#333333\">var</span></strong> lazy = <span style=\"color:#0086b3\">Date</span>.now() + <span style=\"color:#008080\">5</span> * <span style=\"color:#008080\">1000</span>;<br/><strong><span style=\"color:#333333\">while</span></strong>(<span style=\"color:#0086b3\">Date</span>.now() &lt; lazy) {};<br/><br/><span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;b&#x27;</span>);<br/><br/>lazy = <span style=\"color:#0086b3\">Date</span>.now() + <span style=\"color:#008080\">5</span> * <span style=\"color:#008080\">1000</span>;<br/><strong><span style=\"color:#333333\">while</span></strong>(<span style=\"color:#0086b3\">Date</span>.now() &lt; lazy) {};<br/><br/>setTimeout(() =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;c&#x27;</span>);<br/>}, <span style=\"color:#008080\">0</span>);</code></pre><p style=\"text-align:start;\">输出结果为 “b a c”,跟上面结果一样，这貌似更符合我们得出的结论，我们再来看下一个例子：</p><pre><code>setTimeout(() =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;a&#x27;</span>);<br/>}, <span style=\"color:#008080\">0</span>);<br/><br/><strong><span style=\"color:#333333\">new</span></strong> Promise((resolve, reject) =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;d&#x27;</span>);<br/>  resolve();<br/>}).<strong><span style=\"color:#333333\">then</span></strong>(() =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;e&#x27;</span>);<br/>})<br/><br/><span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;b&#x27;</span>);<br/><br/>setTimeout(() =&gt; {<br/>  <span style=\"color:#0086b3\">console</span>.log(<span style=\"color:#dd1144\">&#x27;c&#x27;</span>);<br/>}, <span style=\"color:#008080\">0</span>);</code></pre><p style=\"text-align:start;\">如果是我们之前得出的结论，那么输出结果应该为“d b a e c”,但是我们在控制台打印出的结果是：<br/></p><div class=\"media-wrap image-wrap\"><img src=\"http://blog/7AC23D1E-1960-4D68-AB88-D6383ADE7926.jpeg?ynotemdtimestamp=1559038845797\"/></div><p></p><p><span style=\"color:#24292e\"><span style=\"font-size:14px\">得出的结果并不是我们想的，同步一样是在异步之前执行的，但是异步任务的顺序就不是注册的顺序了，从而我们上面说的“主线程空闲后从异步队列顺序取出任务执行”是错误的，那么除了注册顺序外还有是什么决定着异步任务的执行呢？</span></span></p><p></p><p></p>', 'https://pic4.zhimg.com/80/v2-6694cacc1849d8c6148381aaad1eaf77_hd.jpg', '12', 'js任务队列及事件循环', '[\"js进阶\"]', '2019-05-28 18:24:52', '1', '0', '0'), ('47', 'Blossom ​​​​', '17', '2019-09-27 16:48:06', '0', '0', '<p>嘻嘻嘻</p>', '', '11', '这是文章的简介你知道吗', '[\"haha\",\"xixi\"]', '2019-09-27 16:48:06', '0', '0', '0'), ('48', '文章图片上传测试', '17', '2019-10-24 12:19:01', '11', '0', '<p></p><div class=\"media-wrap image-wrap\"><img src=\"http://localhost:3002/static/302931504@qq.com/article/b2ca9edd9754e.jpeg\"/></div><p></p>', '', '11', '文章上传图片', '[\"测试\"]', '2019-09-27 16:54:36', '1', '0', '0'), ('50', '牛牛的春天', '17', '2019-09-27 18:12:51', '17', '0', '<p></p><div class=\"media-wrap image-wrap\"><img class=\"media-wrap image-wrap\" src=\"http://localhost:3002/static/302931504@qq.com/article/eec1694608602.jpg\"/></div><p></p>', '', '16', '这一篇文章是我修改的', '[\"牛牛\",\"阿何\"]', '2019-09-27 17:26:40', '1', '4', '0'), ('51', '邮件', '17', '2019-10-08 14:48:49', '2', '0', '<p>他</p>', '', '11', '', null, '2019-10-08 14:48:49', '1', '0', '0'), ('52', '邮件', '17', '2019-10-08 16:01:29', '2', '0', '<p>多多岛</p>', '', '11', '邮件邮件邮件邮件', '[\"额外前锋的武器 \"]', '2019-10-08 16:01:29', '1', '0', '0'), ('53', '方法为', '17', '2019-10-08 16:02:46', '3', '0', '<p>为</p>', '', '11', '为反胃反胃', '[\"额外氛围\"]', '2019-10-08 16:02:46', '1', '0', '0'), ('54', 'errew ', '17', '2019-10-08 16:03:56', '4', '0', '<p>werfg </p>', '', '11', 'fw ', '[\"we \"]', '2019-10-08 16:03:56', '1', '0', '0'), ('57', '我，是真是的爱过', '17', '2019-10-08 16:12:35', '8', '0', '<p>实时</p>', '', '11', '如果你要走也带我走', '[\"情歌\"]', '2019-10-08 16:12:35', '1', '0', '0'), ('58', '得不到你', '17', '2019-10-08 18:41:02', '42', '0', '<p>得不到你，你却在我心里，想你，整日整夜都在想你；</p>', '', '16', '得不到你，你却在我心里，想你，整日整夜都在想你；', '[\"隔壁老樊\"]', '2019-10-08 16:15:43', '1', '4', '0'), ('59', 'fewfwefwef', '17', '2019-10-08 16:17:28', '4', '0', '<p>ewfwe</p>', '', '12', 'w ', '[\"wef \"]', '2019-10-08 16:17:28', '1', '0', '0'), ('60', '文章发布测试消息是否被推送', '17', '2019-10-24 11:33:38', '1', '0', '<p>a test article</p>', '', '16', 'test', '[\"测试\",\"JPush\"]', '2019-10-24 11:33:38', '1', '0', '0'), ('61', '文章发布测试消息是否被推送', '17', '2019-10-24 11:34:49', '0', '0', '<p>a test article</p>', '', '16', 'test', '[\"测试\",\"JPush\"]', '2019-10-24 11:34:49', '0', '0', '0'), ('64', '测试推送内容', '17', '2019-10-24 12:01:48', '0', '0', '<p>a test article</p>', '', '16', 'ceshi ', '[\"JPush\"]', '2019-10-24 12:01:48', '0', '0', '0');
COMMIT;

-- ----------------------------
--  Table structure for `author`
-- ----------------------------
DROP TABLE IF EXISTS `author`;
CREATE TABLE `author` (
  `id` int(8) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `account` varchar(255) COLLATE utf8_unicode_ci NOT NULL COMMENT '邮箱',
  `nickname` varchar(255) COLLATE utf8_unicode_ci NOT NULL COMMENT '昵称',
  `password` varchar(255) COLLATE utf8_unicode_ci NOT NULL COMMENT '密码',
  `avator` varchar(500) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '头像',
  `followers` int(16) DEFAULT NULL COMMENT '关注数',
  `bg_cover` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '封面',
  `intro` tinytext COLLATE utf8_unicode_ci COMMENT '自我介绍',
  `admin` tinyint(2) NOT NULL DEFAULT '0',
  `articles` int(6) DEFAULT '0',
  `tweets` int(6) DEFAULT '0',
  `albums` int(6) DEFAULT '0',
  `ide` varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,
  `lock` int(2) NOT NULL DEFAULT '0',
  `rec` int(2) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `author`
-- ----------------------------
BEGIN;
INSERT INTO `author` VALUES ('17', '302931504@qq.com', 'SHUAI_', 'zhangweijian,817', '/server/static/302931504@qq.com/avatar/727b073338597.jpeg', '15', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555182431376&di=14ea5c82d0bac70bcda80b40e13354a6&imgtype=0&src=http%3A%2F%2Fp0.so.qhimgs1.com%2Ft01ff38d8b8b867cc90.jpg', '我要记住你的样子，想鱼记住水的拥抱，想云在天空中停靠。', '1', '17', '7', '3', '全站最屌、', '0', '1'), ('18', '986584713@qq.com', '帅的爸爸', '8bffe80420c9594c728429a74b7f83c3', '/server/static/986584713@qq.com/avatar/08183151bd8d9.jpg', '0', 'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=753302904,945138318&fm=115&gp=0.jpg', null, '0', '2', '1', '0', null, '0', '1'), ('19', '13414367591@163.com', '新用户r1jzymp5isa', '8b4e1ca290008957fe7c47a2641a211e', 'http://wx2.sinaimg.cn/large/006yTYHNly1g1uh704mxtj32c02c0e81.jpg', '0', 'https://wx1.sinaimg.cn/mw690/006YIGvaly1g1i9x32kjoj31jk1jk4bk.jpg', null, '0', '0', '0', '0', null, '0', '0'), ('20', 'Linukswin@163.com', '斯密达', '123456', '/server/static/Linukswin@163.com/avatar/700f4dfeee6bf.jpg', '0', 'https://img.ixiumei.com/uploadfile/2019/0516/20190516032234809.jpg', '我是刘帅他爸爸', '0', '2', '0', '0', '沙雕', '0', '1'), ('21', '1414896783@qq.com', '新用户lo4uq9le9xf', 'bb5cf51b13f72100857d158077c6bece', 'http://www.lsshuai.com/static/images/avatar.png', '0', 'https://wx1.sinaimg.cn/mw690/006YIGvaly1g1i9x32kjoj31jk1jk4bk.jpg', null, '0', '0', '0', '0', null, '0', '0');
COMMIT;

-- ----------------------------
--  Table structure for `blog_comments`
-- ----------------------------
DROP TABLE IF EXISTS `blog_comments`;
CREATE TABLE `blog_comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `host` int(11) NOT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  `useremail` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  `userblog` varchar(255) DEFAULT NULL,
  `replyname` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL,
  `replyemail` varchar(255) DEFAULT NULL,
  `time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `content` text CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  `type` tinyint(4) NOT NULL DEFAULT '1',
  `replycontent` text CHARACTER SET utf8 COLLATE utf8_unicode_ci,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=97 DEFAULT CHARSET=latin1;

-- ----------------------------
--  Records of `blog_comments`
-- ----------------------------
BEGIN;
INSERT INTO `blog_comments` VALUES ('1', '44', '深夜路灯', '123@qq.com', null, null, null, '2019-09-10 16:40:24', '写得很棒！ 学习了！', '1', null), ('2', '44', '洋葱', '13@qq.com', null, null, null, '2019-09-10 16:44:09', '概念有点多，需耐心', '1', null), ('3', '44', '昆山装修吧', 'ddd@qq.com', null, null, null, '2019-09-10 16:44:40', '我就默默看看。', '1', null), ('4', '44', 'Angela的老公', 'sss@qq.com', 'http://www.yangzicong.com', null, null, '2019-09-10 16:45:29', 'web sql和 indexeddb！', '1', null), ('5', '44', '杨子聪', 'ddd@qq.com', null, 'Angela的老公', 'sss@qq.com', '2019-09-10 16:46:15', '我没用过，就不班门弄斧了', '1', 'web sql和 indexeddb！'), ('6', '49', '小杨', 'fwefwe@qq.com', null, null, null, '2019-09-11 17:31:19', '我们一起加油', '2', null), ('7', '49', '刘帅', '302931504@qq.com', null, '小杨', 'ernjin@qq.com', '2019-09-11 17:32:18', '谢谢，静待~', '2', '我们一起加油'), ('8', '0', '曾名', 'ss22@qq.com', null, null, null, '2019-09-12 16:36:50', '你你你你你你要跳舞吗', '3', null), ('9', '0', '刘帅', '302931504@qq.com', null, '曾名', 'ss22@qq.com', '2019-09-12 16:38:08', '跳什么', '3', '你你你你你你要跳舞吗'), ('10', '44', '评论测试', 'test@qq.com', null, null, null, '2019-09-12 18:27:02', '哈哈哈', '1', null), ('11', '44', '测试', 'test@qq.com', null, null, null, '2019-09-12 18:32:05', '我不需要自由，只想陪着他的梦', '1', null), ('12', '44', '测试', 'test@qq.com', null, null, null, '2019-09-12 18:33:26', '跳到评论', '1', null), ('13', '44', '测试', 'test@qq.com', null, '昆山装修吧', 'ddd@qq.com', '2019-09-12 18:45:30', '那你默默的看吧', '1', '我就默默看看。'), ('14', '44', '测试', 'test@qq.com', null, null, null, '2019-09-12 19:24:35', '评论一下', '1', null), ('15', '44', '测试', 'test@qq.com', null, '测试', 'test@qq.com', '2019-09-15 13:00:23', 'lalala', '1', '评论一下'), ('16', '44', '测试', 'test@qq.com', null, '测试', 'test@qq.com', '2019-09-15 13:01:17', 'balabala', '1', 'lalala'), ('17', '54', '测试', 'test@qq.com', null, null, null, '2019-09-15 13:51:23', '评论', '2', null), ('18', '54', '测试', 'test@qq.com', null, null, null, '2019-09-15 13:53:24', '哈哈', '2', null), ('19', '54', '测试', 'test@qq.com', null, '测试', 'test@qq.com', '2019-09-15 13:59:11', 'hello moto', '2', '哈哈'), ('20', '52', '测试', 'test@qq.com', null, null, null, '2019-09-15 14:21:02', '期待', '2', null), ('21', '0', '测试', 'test@qq.com', null, '刘帅', '302931504@qq.com', '2019-09-15 14:31:18', '测试', '3', '跳什么'), ('22', '0', '测试', 'test@qq.com', null, '测试', 'test@qq.com', '2019-09-15 14:33:56', '1234', '3', '测试'), ('23', '54', '测试', 'test@qq.com', null, null, null, '2019-09-16 11:49:18', '评论测试', '2', null), ('24', '0', '测试', 'test@qq.com', null, null, null, '2019-09-16 11:50:29', '我不难过了，甚至真心希望你能把幸福，当我了解你只活在记忆里头。', '3', null), ('26', '44', 'edw', 'wedwe@qq.com', null, null, null, '2019-09-16 12:43:35', 'ewd', '1', null), ('29', '52', '刘帅', '302931504@qq.com', null, '测试', 'test@qq.com', '2019-09-18 11:09:21', '好的', '2', '期待'), ('30', '43', '测试', 'test@qq.com', 'http://www.yangzicong.com', null, null, '2019-09-19 15:23:30', '评论一下', '1', null), ('31', '43', '测试', 'test@qq.com', '', null, null, '2019-09-19 15:24:04', '没有个人站点的评论', '1', null), ('32', '43', '测试', 'test@qq.com', 'http://www.yangzicong.com', null, null, '2019-09-19 15:27:38', '测试用户站点校验', '1', null), ('33', '43', '测试', 'test@qq.com', null, null, null, '2019-09-19 15:27:59', '测试用户站点校验', '1', null), ('34', '43', '测试', 'test@qq.com', 'http://undefinedwww.yangzicong.com', null, null, '2019-09-19 15:28:19', '测试用户站点校验', '1', null), ('36', '0', '测试', 'test@qq.com', 'http://www.lsshuai.com', null, null, '2019-09-19 15:53:13', '用户信息是否保存', '3', null), ('38', '0', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '测试', 'test@qq.com', '2019-09-30 10:41:58', '回复嘻嘻', '3', '用户信息是否保存'), ('39', '0', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', 'njkb', 'bjh@qq.com', '2019-09-30 11:05:54', 'yoyo check out!', '3', 'jkln'), ('40', '0', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '测试', 'test@qq.com', '2019-09-30 11:08:59', '我不难过了，甚至真心希望你能幸福。', '3', '用户信息是否保存'), ('41', '54', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '测试', 'test@qq.com', '2019-09-30 11:11:21', '我已是，陌生人了', '2', '评论'), ('43', '52', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '刘帅', '302931504@qq.com', '2019-09-30 11:14:43', 'skr skr±', '2', '好的'), ('44', '52', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '刘帅_', '302931504@qq.com', '2019-09-30 11:20:29', '原来', '2', 'skr skr±'), ('45', '43', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '测试', 'test@qq.com', '2019-09-30 11:22:31', '原来爱一个人', '1', '测试用户站点校验'), ('47', '1', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '12', 'fewfw@qq.com', '2019-09-30 11:26:00', '擦一擦眼泪吧', '4', '俄绯闻绯闻'), ('48', '0', '测试员', '564798978@qq.com', null, null, null, '2019-10-08 17:00:08', '留言发送邮件测试', '3', null), ('49', '0', '管理员', '302931504@qq.com', null, '测试员', '564798978@qq.com', '2019-10-08 17:01:09', '我作为管理员应该不会触发邮件发送', '3', '留言发送邮件测试'), ('50', '63', '测试', '153074457@qq.com', null, null, null, '2019-10-08 17:11:53', '评论一下这位靓仔', '2', null), ('51', '63', '测试', '153074457@qq.com', null, null, null, '2019-10-08 17:12:51', '再评论一下这位靓仔', '2', null), ('52', '50', '测试', '153074457@qq.com', null, null, null, '2019-10-08 17:27:57', '刺激', '1', null), ('53', '50', '测试', '153074457@qq.com', null, null, null, '2019-10-08 17:28:56', '牛批', '1', null), ('54', '1', '测试', '153074457@qq.com', null, null, null, '2019-10-08 17:31:24', '而我，就变成了，方向', '4', null), ('55', '1', '测试', '153074457@qq.com', null, null, null, '2019-10-08 17:32:04', '笑起来，像个太阳', '4', null), ('56', '63', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '测试', '153074457@qq.com', '2019-10-08 18:01:07', '好的，谢谢', '2', '再评论一下这位靓仔'), ('57', '63', '刘帅_', '302931504@qq.com', 'http://www.lsshuai.com', '测试', '153074457@qq.com', '2019-10-08 18:01:57', '好的，本宫收到了', '2', '评论一下这位靓仔'), ('58', '63', '测试', '153074457@qq.com', null, '刘帅_', '302931504@qq.com', '2019-10-08 18:06:04', '那你很棒啊', '2', '好的，本宫收到了'), ('59', '0', 'shuai', 'shuai@qq.com', null, null, null, '2019-10-11 18:52:59', 'gtgrtg', '3', null), ('60', '0', 'shuai', 'shuai@qq.com', null, null, null, '2019-10-11 18:53:08', 'r5tg54rt45\ng45g4g45', '3', null), ('61', '0', 'shuai', 'shuai@qq.com', null, null, null, '2019-10-11 19:39:28', '是吗，那你很棒哦', '3', null), ('62', '0', 'shuai', 'shuai@qq.com', null, null, null, '2019-10-11 19:40:19', '戒了烟我不习惯\n没有你我怎么办\n三年零一个礼拜\n才学会怎么忍耐', '3', null), ('63', '0', 'shuai', 'shuai@qq.com', null, null, null, '2019-10-11 19:42:49', '每次分别前我们都会把气氛弄得很僵，本来有许多谢谢的话想开心地说给你听，但看着你冷峻的脸和笔直的眼神，我却只剩心酸了。\n\n谢谢你，在日本的一路上都是你在负责路线导游、机票酒店、付钱记账，几乎所有的一切都是你包揽，我只需认真玩，甚至连你自己的行李你也争着要自己拿，你真的很强大。你付出了很多，任劳任怨却还是可以不求回报地完全投入享受这段旅途，在这一点上我分明能感受到你对我的爱意。你真的很好，所以我要认真地谢谢你。\n\n可是我们的感情还是很脆弱，每次一闹完矛盾我就不知该如何面对你，好像大家眼里都没了一点爱意，每到这时我望向你，我心里都是战栗的，很不是滋味。\n我今晚感觉很委屈，因为被你“冤枉”，我是个特别自我的人，不太会放下自己的情绪去照顾你，虽然你一路上已经很辛苦。但我真的很喜欢你了，绝无二心地跟你在一起，你真的该好好回想我们经历过的一切，认识清楚我不是你从来讨厌的“到处撩妹”的人。\n\n我希望你一切都好。\n我或许再也不能有着像刚开始那样坚定的信心，因为我越来越意识到困难是客观的，我们的感情也在不断受挫中变得脆弱。我不是个好脾气的人，我很害怕有一天我们其中一个人就先宣布分开了。可即使如此，在我们面前的许多座山，我仍旧希望我们能够携手度过。\n\n如果我一直都觉得我是能给你最幸福生活的人，那我便一直义无反顾。\n\n不要再考验真爱了，这句话给你也给我。', '3', null), ('64', '64', 'shuai', 'shuai@qq.com', null, null, null, '2019-10-11 19:51:46', '我只想做你的太阳你的太阳，在你i的心底啊在你的心底啊', '2', null), ('65', '0', 'flutter', 'flutter@test.com', null, null, null, '2019-10-17 22:23:12', 'flutter comment test', '3', null), ('66', '0', 'flutter', 'flutter@test.com', null, null, null, '2019-10-17 22:32:35', 'flutter\nflutter', '3', null), ('67', '0', 'flutter', 'flutter@test.com', null, null, null, '2019-10-17 22:34:03', 'hello flutter!!!\nhello world!!!', '3', null), ('68', '0', 'flutter_back', 'flutter@qq.com', null, 'flutter', 'flutter@test.com', '2019-10-18 10:37:44', 'quto flutter leave message', '3', 'flutter comment test'), ('69', '50', 'flutter', 'flutter@test.com', null, '测试', '153074457@qq.com', '2019-10-18 10:41:56', 'flutter answer test', '1', '牛批'), ('70', '50', 'flutter', 'flutter@test.com', null, null, null, '2019-10-18 10:46:53', 'flutter message leave test', '1', null), ('71', '1', 'flutter', 'flutter@test.com', null, '测试', '153074457@qq.com', '2019-10-18 10:53:20', 'flutter answer your message', '4', '笑起来，像个太阳'), ('72', '2', 'flutter', 'flutter@test.com', null, null, null, '2019-10-18 11:05:55', 'flutter leave message test', '4', null), ('73', '1', 'flutter', 'flutter@test.com', null, '刘帅_', '302931504@qq.com', '2019-10-18 11:06:42', 'flutter answer test', '4', '擦一擦眼泪吧'), ('74', '63', 'flutter', 'flutter@test.com', null, '测试', '153074457@qq.com', '2019-10-18 12:00:42', 'flutter answer message test', '2', '评论一下这位靓仔'), ('75', '58', 'flutter', 'flutter@test.com', null, null, null, '2019-10-18 12:07:30', ' [/tantan8] cause  [/tantan8]  if you like the way you look that much so bony you should go and love yourself', '1', null), ('76', '64', 'flutter', 'test@we.com', null, null, null, '2019-10-18 12:32:52', 'flutter leave message test', '2', null), ('77', '63', 'jj', 'dfqwe@we.com', null, null, null, '2019-10-18 15:07:23', 'lalala', '2', null), ('78', '63', 'wefwe', 'qf', null, null, null, '2019-10-18 15:07:36', 'jiohjihweiofhweoihf92wgbefvubdcpvhweufhc', '2', null), ('79', '63', 'ewdfw', 'fewqf@we.com', null, null, null, '2019-10-18 15:07:52', 'ewgdyqwedbiuqgwdcuqewvciuwgcuiguiwgfugwe\ngewqyduvewdfyv', '2', null), ('80', '63', 'test', 'test@we.com', null, null, null, '2019-10-18 15:08:20', 'hello honey', '2', null), ('81', '63', 'trg', 'ref@qq.com', null, null, null, '2019-10-18 15:08:43', 'burfe3', '2', null), ('82', '0', 'flutter', 'fllutter@test.com', null, null, null, '2019-10-19 16:57:59', 'message save', '3', null), ('83', '0', 'flutter', 'fllutter@test.com', null, null, null, '2019-10-19 17:09:34', 'FLUTTER INFO TEST', '3', null), ('84', '0', 'flutter', 'fllutter@test.com', null, null, null, '2019-10-19 17:09:49', 'REMOVE INFO TEST', '3', null), ('85', '0', 'efwe', 'wefwe@qq.com', null, null, null, '2019-10-21 18:51:14', 'efewfwe [/tantan8] ', '3', null), ('86', '58', 'test', 'sss@qq.com', null, null, null, '2019-11-01 12:22:38', '<p style=\"color: red;\">123</p>', '1', null), ('87', '58', 'test', 'sss@qq.com', null, null, null, '2019-11-01 12:36:14', '<script>alert(\'haha)</script>', '1', null), ('88', '58', 'test', 'sss@qq.com', null, null, null, '2019-11-01 12:36:26', ' [/tantan2] ', '1', null), ('89', '0', 'test', 'sss@qq.com', null, 'efwe', 'wefwe@qq.com', '2019-11-01 14:01:37', 'haha', '3', 'efewfwe [/tantan8] '), ('90', '0', 'test', 'sss@qq.com', null, null, null, '2019-11-01 15:22:16', ' [/tantan80] ', '3', null), ('91', '2', 'test', 'sss@qq.com', null, null, null, '2019-11-01 15:24:24', ' [/tantan7]  [/tantan12/jpg] ', '4', null), ('92', '0', 'test', 'sss@qq.com', null, null, null, '2019-11-01 16:15:36', ' [/tantan16] ', '3', null), ('93', '0', 'test', 'sss@qq.com', null, null, null, '2019-11-04 14:52:34', ' [/我可以摸你的咪咪吗] ', '3', null), ('94', '0', 'test', 'sss@qq.com', null, null, null, '2019-11-04 14:55:23', ' [/端庄] ', '3', null), ('95', '0', 'test', 'sss@qq.com', null, 'test', 'sss@qq.com', '2019-11-04 14:55:31', ' [/你从屏幕里出来打我呀] ', '3', ' [/端庄] '), ('96', '0', 'test', 'sss@qq.com', 'http://www.yangzicong.com', null, null, '2019-11-06 11:12:14', '没有链接吗 [/比在意自己的胸更在意] ', '3', null);
COMMIT;

-- ----------------------------
--  Table structure for `blogfollower`
-- ----------------------------
DROP TABLE IF EXISTS `blogfollower`;
CREATE TABLE `blogfollower` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=latin1;

-- ----------------------------
--  Records of `blogfollower`
-- ----------------------------
BEGIN;
INSERT INTO `blogfollower` VALUES ('4', '订阅测试', '153074457@qq.com'), ('6', '培森儿子的爸爸', '302931504@qq.com'), ('8', '阿刁给我的号', '564798978@qq.com'), ('9', 'w', 'sss@qq.com'), ('10', 'eee', 'eeeee@qq.com'), ('11', 'ddrfer', 'efwef@qq.com'), ('12', 'r34r34', 'ewfwe@qq.com'), ('13', '张卫健', 'sdqwdq@qq.com'), ('14', 'weq3e', '3e23r@qq.com'), ('15', 'shwquifdbg', 'weffe2qwwgv@qq.com'), ('16', 'r5tg35', 'fewwefg@qq.com'), ('17', 'y5y3344', 'wefgweq@qq.com'), ('18', 'fwef', 'fewew@qq.com'), ('20', 'flutter', 'flutter@test.com');
COMMIT;

-- ----------------------------
--  Table structure for `breadcast`
-- ----------------------------
DROP TABLE IF EXISTS `breadcast`;
CREATE TABLE `breadcast` (
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `time` datetime NOT NULL,
  `content` text COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `breadcast`
-- ----------------------------
BEGIN;
INSERT INTO `breadcast` VALUES ('7', '2019-05-29 18:54:48', '博客社区1.2已经更新发布，1.2版本修复了之前存留的一些bug');
COMMIT;

-- ----------------------------
--  Table structure for `chanelfollow`
-- ----------------------------
DROP TABLE IF EXISTS `chanelfollow`;
CREATE TABLE `chanelfollow` (
  `id` int(6) NOT NULL AUTO_INCREMENT,
  `ownid` int(8) NOT NULL,
  `cid` int(8) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `chanelfollow`
-- ----------------------------
BEGIN;
INSERT INTO `chanelfollow` VALUES ('11', '17', '12');
COMMIT;

-- ----------------------------
--  Table structure for `channel`
-- ----------------------------
DROP TABLE IF EXISTS `channel`;
CREATE TABLE `channel` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `cname` varchar(100) COLLATE utf8_unicode_ci NOT NULL COMMENT '名字',
  `createtime` timestamp NULL DEFAULT NULL COMMENT '创建时间',
  `cdesc` text COLLATE utf8_unicode_ci COMMENT '简介',
  `cimg` varchar(500) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '封面',
  `boss` int(8) NOT NULL DEFAULT '0',
  `followers` int(6) NOT NULL DEFAULT '0',
  `articlecount` int(6) NOT NULL DEFAULT '0',
  `albumcount` int(6) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `channel`
-- ----------------------------
BEGIN;
INSERT INTO `channel` VALUES ('11', '沙雕网友', '2019-04-15 11:00:01', '辣鸡站长，在线发pei', '/server/static/986584713@qq.com/channel/4141d5e5c397a.png', '18', '0', '10', '2'), ('12', '前端', '2019-04-15 22:42:09', '前端技术文章集合', '/server/static/302931504@qq.com/channel/444959da95aa2.jpeg', '0', '1', '5', '0'), ('13', '测试频道', '2019-04-15 22:49:32', '测试灌水频道', '/server/static/302931504@qq.com/channel/4d7bd648b9786.jpeg', '0', '0', '0', '0'), ('14', '数据结构', '2019-04-17 10:47:24', '数据结构', '/server/static/986584713@qq.com/channel/4141d5e5c397a.png', '20', '0', '2', '0'), ('15', '新增分类测试', '2019-09-27 16:19:15', '', '/server/static/986584713@qq.com/channel/4141d5e5c397a.png', '17', '0', '0', '0'), ('16', '牛牛的春天', '2019-09-27 16:20:58', '', '/server/static/986584713@qq.com/channel/4141d5e5c397a.png', '17', '0', '4', '0');
COMMIT;

-- ----------------------------
--  Table structure for `child_comment`
-- ----------------------------
DROP TABLE IF EXISTS `child_comment`;
CREATE TABLE `child_comment` (
  `child_comment_id` int(8) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `parent_id` int(8) NOT NULL COMMENT '父留言id(外键)',
  `pubtime` datetime DEFAULT NULL COMMENT '发布时间',
  `content` text COLLATE utf8_unicode_ci COMMENT '内容',
  `req_user_name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '回复对象昵称',
  `res_user_name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '被回复对象昵称',
  `req_user_id` int(8) NOT NULL,
  `res_user_id` int(8) NOT NULL,
  PRIMARY KEY (`child_comment_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `child_comment`
-- ----------------------------
BEGIN;
INSERT INTO `child_comment` VALUES ('64', '73', '2019-04-14 00:49:44', '\n加薇：vgd1984112（手动滑稽）', '帅爸爸', 'SHUAI.', '18', '17'), ('65', '76', '2019-04-15 23:52:25', '有阴阳\n', '火韦日月', 'SHUAI', '20', '17'), ('66', '85', '2019-08-04 13:33:32', '在不换头像我可要屏蔽你了', '落尔布', 'SHUAI.', '20', '17'), ('67', '85', '2019-08-07 14:55:42', 'hahahahahaha', 'dss', 'fgrg', '17', '20');
COMMIT;

-- ----------------------------
--  Table structure for `comments`
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments` (
  `comment_id` int(8) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_id` int(8) DEFAULT NULL COMMENT '评论指向id(外键)',
  `content` text COLLATE utf8_unicode_ci COMMENT '内容',
  `userid` int(8) DEFAULT '0',
  `pubtime` datetime DEFAULT NULL COMMENT '发布时间',
  `type` int(4) DEFAULT NULL COMMENT '指向(文章/帖子)',
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=108 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `comments`
-- ----------------------------
BEGIN;
INSERT INTO `comments` VALUES ('73', '31', '假笑男孩', '17', '2019-04-14 00:49:44', '4'), ('74', '49', 'huifu ', '17', '2019-04-15 10:37:13', '2'), ('75', '50', '爸爸真帅', '18', '2019-04-15 10:48:54', '2'), ('76', '18', '服务端通过采用gzip来减小文件体积，从而提升文件加载速度。', '17', '2019-04-15 23:52:25', '3'), ('77', '18', '后台如何进入前台页？后台管理导航栏，下拉框都打开时，下面的一些样式就出错了。。', '20', '2019-04-17 11:02:46', '3'), ('78', '18', '文章编辑器不支持 markdown ，上传的文章无法正常显示。', '20', '2019-04-17 11:04:37', '3'), ('79', '18', '需要新增消息推送功能，当文章有新评论时或者评论被回复时主播能够收到相应的提醒消息', '17', '2019-04-18 17:31:24', '3'), ('80', '33', '莫纳汉是真的帅！', '17', '2019-07-03 14:53:18', '4'), ('81', '33', 'hahahahahahaha', '17', '2019-08-04 13:11:20', '4'), ('82', '33', '打不过我吧，没有办法我就是这么强大', '17', '2019-08-04 13:11:49', '4'), ('86', '41', 'dsfdefweeed', '20', '2019-08-07 11:21:27', '1'), ('87', '41', 'wefwefweff', '20', '2019-08-07 11:23:10', '1'), ('88', '41', 'fgergferge', '20', '2019-08-07 14:37:25', '1'), ('89', '41', 'rwetweferwfg', '20', '2019-08-07 14:37:48', '1'), ('90', '41', 'wefdwefdwe', '20', '2019-08-07 14:38:06', '1'), ('91', '41', 'ewrwerwerwd', '20', '2019-08-07 14:38:20', '1'), ('92', '41', 'fcsdfwefdew', '20', '2019-08-07 14:38:35', '1'), ('93', '41', 'wefwefwef', '20', '2019-08-07 14:38:48', '1'), ('94', '41', 'werfrefwer', '17', '2019-08-07 14:39:06', '1'), ('95', '41', 'wefewfwef', '17', '2019-08-07 14:39:19', '1'), ('96', '41', 'yhtynbrtverg', '20', '2019-08-07 14:39:35', '1'), ('97', '52', 'regergege', '20', '2019-08-07 14:39:49', '2'), ('98', '52', 'sgdwervwfv', '20', '2019-08-07 14:40:00', '2'), ('99', '52', 'dfbefbvewr', '20', '2019-08-07 14:40:12', '2'), ('100', '41', 'dgergverbe', '20', '2019-08-07 14:40:25', '1'), ('101', '33', '哈哈', '20', '2019-08-17 18:13:58', '4'), ('102', '33', '是吗？', '17', '2019-08-17 18:20:54', '4'), ('103', '33', '太可以了', '17', '2019-08-17 18:28:40', '4'), ('104', '33', '。', '17', '2019-08-17 18:30:21', '4'), ('105', '33', '好美啊', '17', '2019-08-17 18:31:54', '4'), ('106', '32', 'I can very much', '17', '2019-08-17 18:49:29', '4'), ('107', '33', '时间', '17', '2019-08-22 17:03:55', '4');
COMMIT;

-- ----------------------------
--  Table structure for `follows`
-- ----------------------------
DROP TABLE IF EXISTS `follows`;
CREATE TABLE `follows` (
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `own_id` int(8) NOT NULL,
  `user_id` int(8) NOT NULL,
  `each` int(2) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `follows`
-- ----------------------------
BEGIN;
INSERT INTO `follows` VALUES ('1', '17', '18', '0');
COMMIT;

-- ----------------------------
--  Table structure for `forum`
-- ----------------------------
DROP TABLE IF EXISTS `forum`;
CREATE TABLE `forum` (
  `id` int(8) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `author` int(8) NOT NULL,
  `pubtime` timestamp NULL DEFAULT NULL,
  `views` int(10) DEFAULT NULL,
  `content` text COLLATE utf8_unicode_ci,
  `top` tinyint(2) DEFAULT '0',
  `choice` tinyint(2) DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `forum`
-- ----------------------------
BEGIN;
INSERT INTO `forum` VALUES ('17', '新人报到', '18', '2019-04-14 00:45:33', '13', '<p></p><div class=\"media-wrap image-wrap\"><img src=\"/server/static/986584713@qq.com/forum/a091c742d98e5.png\"/></div><p></p>', '0', '0'), ('18', '博客bug&&用户体验收集', '17', '2019-04-18 17:34:06', '27', '<p style=\"text-align:center;\"><span style=\"font-size:32px\"><strong><span style=\"background-color:#fdda00\">博客新上线</span></strong></span></p><p></p><p>还有很多隐藏bug，这几天陆续改了一些，但还有一些小bug等待被发现，同时后台系统加载速度比较慢，这是一个比较大的问题，目前主要问题是后台系统打包出来后第三方库文件有1M多大，其他执行文件有接近1M大，后续再努力优化一下；</p><p></p><p>还有使用过程中遇到什么问题，任何bug，有什么好的建议都可以在此贴下面回复</p><p></p><p>谢谢～</p><p></p><p>已修复：</p><ol><li><span style=\"color:#ffffff\"><span style=\"background-color:#d35400\">控制台系统路由采用来加载和后段使用gzip来提升加载速度</span></span></li><li><span style=\"background-color:#d35400\"><span style=\"color:#ffffff\">修复帖子不能回复的bug</span></span></li></ol>', '1', '0');
COMMIT;

-- ----------------------------
--  Table structure for `imgs`
-- ----------------------------
DROP TABLE IF EXISTS `imgs`;
CREATE TABLE `imgs` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `src` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `pid` int(8) NOT NULL,
  `type` int(8) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=75 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `imgs`
-- ----------------------------
BEGIN;
INSERT INTO `imgs` VALUES ('52', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555183231634&di=adae467a9c3996b9dad86b1d1acb103e&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201802%2F11%2F20180211184725_MvyVE.jpeg', '31', '4'), ('53', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555183231634&di=75bdc28666eff5d45273c08db03bd24c&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201802%2F14%2F20180214110722_jzie5.thumb.700_0.jpeg', '31', '4'), ('54', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1555183231633&di=41876cd64afb8ec58e75f1f3729dccc2&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201802%2F04%2F20180204152104_evdfk.jpg', '31', '4'), ('60', '/server/static/302931504@qq.com/album/6a6b46986363.jpeg', '32', '4'), ('61', '/server/static/302931504@qq.com/album/6a6b46986363.jpeg', '32', '4'), ('62', '/server/static/302931504@qq.com/album/6a6b46986363.jpeg', '32', '4'), ('63', '/server/static/302931504@qq.com/album/21087446e08f5.jpeg', '33', '4'), ('64', '/server/static/302931504@qq.com/album/66eb6c784c601.jpeg', '33', '4'), ('65', '/server/static/302931504@qq.com/album/6a6b46986363.jpeg', '33', '4'), ('66', '/server/static/302931504@qq.com/album/9718a5f88731f.jpeg', '34', '4'), ('67', '/server/static/302931504@qq.com/album/46dcfe617ecdb.jpeg', '34', '4'), ('68', '/server/static/302931504@qq.com/album/06c574a38bc66.jpeg', '34', '4'), ('69', '/server/static/302931504@qq.com/album/446389f21f1c3.jpeg', '34', '4'), ('70', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1562560490309&di=7c4447fd9a28db7799239476f0829951&imgtype=0&src=http%3A%2F%2Fpic2.zhimg.com%2Fv2-f2e69bca31d3d5b5e455ad3b299afd8f_1200x500.jpg', '51', '2'), ('71', 'http://www.yangzicong.com/walkingblog/1566980892283.gif', '54', '2'), ('73', '/server/static/302931504@qq.com/bibi/64059b7537999.jpeg', '58', '2'), ('74', '/server/static/302931504@qq.com/bibi/64059b7537999.jpeg', '63', '2');
COMMIT;

-- ----------------------------
--  Table structure for `message`
-- ----------------------------
DROP TABLE IF EXISTS `message`;
CREATE TABLE `message` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `sid` int(8) NOT NULL,
  `content` text NOT NULL,
  `rid` int(8) NOT NULL,
  `rname` varchar(255) NOT NULL,
  `time` datetime NOT NULL,
  `isread` int(2) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `message`
-- ----------------------------
BEGIN;
INSERT INTO `message` VALUES ('17', '18', '刘帅笑起来好像蔡徐坤', '18', '帅爸爸', '2019-04-15 10:52:11', '1'), ('18', '18', '你打篮球的样子好像cxk', '20', '新用户j8uxlfij1cr', '2019-04-15 10:53:56', '1'), ('19', '18', '你打篮球的样子好像cxk', '17', 'SHUAI.', '2019-04-15 10:53:56', '1'), ('20', '17', '你吃到屎了？', '18', '帅爸爸', '2019-04-15 17:26:58', '1'), ('21', '18', 'shi，给你', '17', 'SHUAI.', '2019-04-15 23:31:40', '1'), ('22', '17', '发文章啦你个大傻逼', '18', '帅爸爸', '2019-04-16 23:41:09', '1'), ('23', '17', '发文章啦你这个臭鸡巴', '20', '林达', '2019-04-16 23:41:33', '1'), ('24', '18', 'gun啦 大傻逼', '17', 'SHUAI', '2019-04-16 23:41:48', '1'), ('25', '20', '草，慢的要死', '17', 'SHUAI', '2019-04-17 10:42:12', '1'), ('26', '20', '草，慢的要死', '17', 'SHUAI', '2019-04-17 10:42:12', '1'), ('27', '17', '你死了吗哪里慢了你这个狗东西', '20', '林达', '2019-04-17 22:02:04', '0'), ('28', '17', '你死了是不是，为什么要发送两条', '20', '林达', '2019-04-18 17:47:38', '1'), ('29', '17', '狗明快去更新', '20', '斯密达', '2019-05-28 16:22:45', '1');
COMMIT;

-- ----------------------------
--  Table structure for `messboard`
-- ----------------------------
DROP TABLE IF EXISTS `messboard`;
CREATE TABLE `messboard` (
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `userid` int(8) NOT NULL,
  `content` text COLLATE utf8_unicode_ci NOT NULL,
  `time` datetime NOT NULL,
  `avatar` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `sname` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `semail` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `sblog` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `type` int(4) NOT NULL DEFAULT '1',
  `parentid` int(8) NOT NULL DEFAULT '0',
  `childs` int(10) NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `messboard`
-- ----------------------------
BEGIN;
INSERT INTO `messboard` VALUES ('28', '18', '傻狗gay韬', '2019-04-29 12:21:10', '/server/static/302931504@qq.com/avatar/727b073338597.jpeg', 'SHUAI', '302931504@qq.com', '/a/17', '1', '0', '0'), ('29', '20', '狗逼明快去发文章', '2019-04-29 12:21:53', '/server/static/302931504@qq.com/avatar/727b073338597.jpeg', 'SHUAI', '302931504@qq.com', '/a/17', '1', '0', '0'), ('30', '18', '日常催更', '2019-05-06 15:57:21', '/server/static/302931504@qq.com/avatar/727b073338597.jpeg', 'SHUAI', '302931504@qq.com', '/a/17', '1', '0', '0'), ('31', '20', '日常催更\n', '2019-05-06 15:57:51', '/server/static/302931504@qq.com/avatar/727b073338597.jpeg', 'SHUAI', '302931504@qq.com', '/a/17', '1', '0', '0');
COMMIT;

-- ----------------------------
--  Table structure for `movie`
-- ----------------------------
DROP TABLE IF EXISTS `movie`;
CREATE TABLE `movie` (
  `id` int(4) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `cover` varchar(255) NOT NULL,
  `type` varchar(255) NOT NULL,
  `tag` varchar(255) DEFAULT NULL,
  `director` varchar(255) DEFAULT NULL,
  `actor` varchar(255) DEFAULT NULL,
  `desc` text,
  `content` text NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records of `movie`
-- ----------------------------
BEGIN;
INSERT INTO `movie` VALUES ('1', '行尸走肉', 'http://hbimg.b0.upaiyun.com/f8ddf808d0bab6d43cc5cebc25cca465e485d89410170-rqIFfg_fw658', '美剧', '恐怖/血腥/人性', '弗兰克·德拉邦特', '安德鲁·林肯、诺曼·瑞杜斯、劳伦·科汉、史蒂文·元', '《行尸走肉》是一部由弗兰克·德拉邦特执导的美国恐怖电视系列剧，安德鲁·林肯、诺曼·瑞杜斯、劳伦·科汉、史蒂文·元等主演。改编自同名漫画，该剧于2010年10月31日在AMC有线电视网开播，是电视史上第一部正宗的丧尸电视剧。 该剧主要讲述的是主人公瑞克是亚特兰大城郊一座小镇的副警长。在执行公务的过程中，瑞克遭到枪击，伤势严重，被人紧急送往当地医院进行抢救。当瑞克醒来之后发现，世界已经丧尸蔓延、危机四伏。', '《行尸走肉》是一部由弗兰克·德拉邦特执导的美国恐怖电视系列剧，安德鲁·林肯、诺曼·瑞杜斯、劳伦·科汉、史蒂文·元等主演。改编自同名漫画，该剧于2010年10月31日在AMC有线电视网开播，是电视史上第一部正宗的丧尸电视剧。 该剧主要讲述的是主人公瑞克是亚特兰大城郊一座小镇的副警长。在执行公务的过程中，瑞克遭到枪击，伤势严重，被人紧急送往当地医院进行抢救。当瑞克醒来之后发现，世界已经丧尸蔓延、危机四伏。'), ('2', '地球百子', 'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571128235743&di=1598cf9bc27a8dd7117822ab677c973d&imgtype=0&src=http%3A%2F%2Fstatic.zongheng.com%2Fupload%2Fcover%2F2015%2F02%2F1424529012598.jpg', '美剧', '恐怖/科幻', null, null, null, '<p></p><div class=\"media-wrap image-wrap\"><img src=\"/server/static/302931504@qq.com/article/3e4e198aac2d1.jpeg\"/></div><p></p><p><span style=\"letter-spacing:1px\"><span style=\"line-height:1.5\">漫威电影观看顺序第一阶段：《钢铁侠》，《无敌浩克》，《钢铁侠2》，《雷神》，《美国队长》，《复仇者联盟》</span></span></p><p><span style=\"letter-spacing:1px\"><span style=\"line-height:1.5\">漫威电影观看顺序第二阶段：《钢铁侠3》，《雷神2》，《美国队长2》，《银河护卫队》，《复仇者联盟2：奥创纪元》，《蚁人》</span></span></p><p><span style=\"letter-spacing:1px\"><span style=\"line-height:1.5\">漫威电影观看顺序第三阶段：《美国队长3：英雄内战》，《奇异博士》，《银河护卫队2》，《蜘蛛侠：英雄归来》，《雷神3：诸神的黄昏》，《黑豹》</span></span></p>'), ('3', 'The Flash', 'http://i2.sinaimg.cn/ent/2014/1014/U5913P28DT20141014165825.jpg', '美剧', '科幻/DC/英雄', null, null, null, '123'), ('4', '昆池岩', 'http://image.xmcdn.com/group43/M06/94/3F/wKgKklr1LG_C4kM2AAPCZfJdQ0U404.jpg', '电影', '恐怖', null, null, null, '123'), ('5', '忠犬八公', 'http://5b0988e595225.cdn.sohucs.com/images/20180216/fc109cc5be284b7595462b8ac1ef9679.jpeg', '电影', '感人/柴犬', null, null, null, '123'), ('6', '行尸之惧', 'http://wx3.sinaimg.cn/large/7768b183gy1fqerr19oz2j20th15odqr.jpg', '美剧', '恐怖/血腥', null, null, null, '123');
COMMIT;

-- ----------------------------
--  Table structure for `tweet`
-- ----------------------------
DROP TABLE IF EXISTS `tweet`;
CREATE TABLE `tweet` (
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `pubtime` datetime DEFAULT NULL,
  `userid` int(8) NOT NULL,
  `content` text COLLATE utf8_unicode_ci NOT NULL,
  `fromw` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `like_num` int(10) DEFAULT '0',
  `video` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `imgs` text COLLATE utf8_unicode_ci,
  `show` int(2) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=65 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;

-- ----------------------------
--  Records of `tweet`
-- ----------------------------
BEGIN;
INSERT INTO `tweet` VALUES ('49', '2019-04-14 19:14:06', '17', '后台系统进去是真的卡', '[\"ka\"]', '0', '', null, '1'), ('50', '2019-04-15 10:48:02', '18', '（狗头保命）', '[\"沙雕网友\"]', '0', '', null, '1'), ('51', '2019-04-18 18:02:00', '17', '烦躁，有些功能都不想加了，想开始写论文了！', '[]', '1', '', null, '1'), ('52', '2019-07-08 09:47:04', '17', '一波预告，接下来我将定期分享vue源码解析了～', '[]', '0', '', null, '1'), ('54', '2019-08-11 14:29:03', '17', 'sdfsdfsdf', '[]', '0', null, null, '1'), ('55', '2019-08-19 16:28:55', '18', 'Branding is no longer simply about visual appeal (or the cherry in the apple pie example, as given in my earlier article). Unfortunately, many graphic design firms who position themselves as advertising agencies believe that branding your corporate identity is all about developing great looking visual solutions.', null, '0', null, null, '1'), ('57', '2019-09-25 16:17:49', '17', '相信你只是怕伤害我，不是骗我', '[\"123\",\"sss\"]', '0', '', null, '1'), ('63', '2019-09-25 16:34:15', '17', '这是一位靓仔', '[\"靓仔\"]', '1000', '', null, '1'), ('64', '2019-10-11 19:46:13', '17', '每次分别前我们都会把气氛弄得很僵，本来有许多谢谢的话想开心地说给你听，但看着你冷峻的脸和笔直的眼神，我却只剩心酸了。\n\n谢谢你，在日本的一路上都是你在负责路线导游、机票酒店、付钱记账，几乎所有的一切都是你包揽，我只需认真玩，甚至连你自己的行李你也争着要自己拿，你真的很强大。你付出了很多，任劳任怨却还是可以不求回报地完全投入享受这段旅途，在这一点上我分明能感受到你对我的爱意。你真的很好，所以我要认真地谢谢你。\n\n可是我们的感情还是很脆弱，每次一闹完矛盾我就不知该如何面对你，好像大家眼里都没了一点爱意，每到这时我望向你，我心里都是战栗的，很不是滋味。\n我今晚感觉很委屈，因为被你“冤枉”，我是个特别自我的人，不太会放下自己的情绪去照顾你，虽然你一路上已经很辛苦。但我真的很喜欢你了，绝无二心地跟你在一起，你真的该好好回想我们经历过的一切，认识清楚我不是你从来讨厌的“到处撩妹”的人。\n\n我希望你一切都好。\n我或许再也不能有着像刚开始那样坚定的信心，因为我越来越意识到困难是客观的，我们的感情也在不断受挫中变得脆弱。我不是个好脾气的人，我很害怕有一天我们其中一个人就先宣布分开了。可即使如此，在我们面前的许多座山，我仍旧希望我们能够携手度过。\n\n如果我一直都觉得我是能给你最幸福生活的人，那我便一直义无反顾。\n\n不要再考验真爱了，这句话给你也给我。', null, '8', null, null, '0');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
